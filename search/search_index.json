{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Django \u00bfPor qu\u00e9 Django? Introducci\u00f3n Configuraci\u00f3n Inicial Hello World app Pages app Message Board app Blog app Formularios Cuentas de Usuarios Modelo de Usuario Personalizado Autenticaci\u00f3n de Usuarios Bootstrap Cambio y Restauraci\u00f3n de contrase\u00f1as Email Newspaper app Permisos y Autorizaci\u00f3n Comentarios Docker","title":"Django"},{"location":"#django","text":"","title":"Django"},{"location":"#por-que-django","text":"","title":"\u00bfPor qu\u00e9 Django?"},{"location":"#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"#configuracion-inicial","text":"","title":"Configuraci\u00f3n Inicial"},{"location":"#hello-world-app","text":"","title":"Hello World app"},{"location":"#pages-app","text":"","title":"Pages app"},{"location":"#message-board-app","text":"","title":"Message Board app"},{"location":"#blog-app","text":"","title":"Blog app"},{"location":"#formularios","text":"","title":"Formularios"},{"location":"#cuentas-de-usuarios","text":"","title":"Cuentas de Usuarios"},{"location":"#modelo-de-usuario-personalizado","text":"","title":"Modelo de Usuario Personalizado"},{"location":"#autenticacion-de-usuarios","text":"","title":"Autenticaci\u00f3n de Usuarios"},{"location":"#bootstrap","text":"","title":"Bootstrap"},{"location":"#cambio-y-restauracion-de-contrasenas","text":"","title":"Cambio y Restauraci\u00f3n de contrase\u00f1as"},{"location":"#email","text":"","title":"Email"},{"location":"#newspaper-app","text":"","title":"Newspaper app"},{"location":"#permisos-y-autorizacion","text":"","title":"Permisos y Autorizaci\u00f3n"},{"location":"#comentarios","text":"","title":"Comentarios"},{"location":"#docker","text":"","title":"Docker"},{"location":"01_que_es_arduino/","text":"\u00bfQu\u00e9 es Arduino? Arduino es una placa controladora y su entorno de programaci\u00f3n que permiten de manera r\u00e1pida y sencilla realizar proyectos de electr\u00f3nica, automatismo, control, dom\u00f3tica, etc. Arduino naci\u00f3 en el Instituto IVREA (Italia) para facilitar a sus alumnos las tareas de programaci\u00f3n de microcontroladores. Es ese uno de los motivos de su \u00e9xito: cualquier persona con pocos conocimientos de inform\u00e1tica y electr\u00f3nica puede programarlo e implementarlo. Existen varios modelos de Arduino como son Uno, Leonardo, Mega... pero este tutorial se limitar\u00e1 salvo que se diga lo contrario al modelo Uno por ser el m\u00e1s com\u00fan y econ\u00f3mico. Hardware libre El otro motivo del gran \u00e9xito de esta plataforma podemos encontrarlo en que es desarrollado c\u00f3mo hardware libre . \u00bfqu\u00e9 es eso de hardware libre? Pues es lo an\u00e1logo al software libre . Sus esquemas, especificaciones y planos est\u00e1n disponibles al p\u00fablico, por tanto cualquiera que acceda a ellos puede fabricarse una copia id\u00e9ntica al original. Pero no s\u00f3lo eso, adem\u00e1s, cualquier usuario o fabricante puede crear accesorios compatibles con lo que las posibilidades de realizar nuevos proyectos se multiplican. Esto atrae nuevos usuarios, algunos de los cuales crean nuevos accesorios y tienen nuevas ideas con lo que estamos retroalimentando una comunidad de usuarios y fabricantes que no para de crecer. Open Source (Recursos): Que es el Open Source explicado con Lego Que es el Software Libre segun Richard Stallman How Arduino is opensourcing imagination Qu\u00e9 es del movimiento maker , 10 a\u00f1os despu\u00e9s que fuese a cambiar el mundo Pensamiento Computacional: Que es el pensamiento computacional- Programamos Computational Thinking- Art\u00edculo Jeannette M. Wing Proyectos educativos Open Source: Escornabot : Escornabot es un proyecto de c\u00f3digo/hardware abierto cuyo objetivo es acercar la rob\u00f3tica y la programaci\u00f3n a los ni\u00f1os y ni\u00f1as. EchidnaShield : EchidnaShield es un proyecto Open Source dirigido a facilitar el aprendizaje de la programaci\u00f3n de sistemas f\u00edsicos en los \u00faltimos cursos de Primaria y en Secundaria Edub\u00e1sica : Escudo para Arduino y pr\u00e1cticas de programaci\u00f3n \u00bfPara qu\u00e9 sirve? Si est\u00e1s leyendo esto seguramente es porque ya le has visto alguna aplicaci\u00f3n y te ha picado el gusanillo. Aqu\u00ed veremos algunas aplicaciones aunque las posibilidades son tantas como las que permite cualquier placa con microcontrolador: infinitas. En general, podemos decir que un microcontrolador se utiliza para ordenar una serie de acciones en funci\u00f3n de las entradas que le lleguen. Por ejemplo, encender un ventilador cuando la lectura de temperatura supere un cierto valor. Otras veces su tarea es realizar una serie de acciones sucesivamente sin hacer ninguna lectura. \u00c9ste caso ser\u00eda el de utilizar Arduino para encender alternativamente las luces de un sem\u00e1foro. Cuando acabes el tutorial seguro que se te ocurren decenas de proyectos que podr\u00e1s realizar. Partes de Arduino En este apartado veremos las distintas partes que conformar nuestro Arduino como son entradas, salidas, alimentaci\u00f3n, comunicaci\u00f3n y shields. Entradas: son los pines de nuestra placa que podemos utilizar para hacer lecturas. En la placa Uno son los pines digitales (del 0 al 13) y los anal\u00f3gicos (del A0 al A5). Salidas: los pines de salidas se utilizan para el env\u00edo de se\u00f1ales. En este caso los pines de salida son s\u00f3lo los digitales (0 a 13). Otros pines: tambi\u00e9n tenemos otros pines como los GND (tierra), 5V que proporciona 5 Voltios, 3.3V que proporciona 3.3 Voltios, los pines REF de referencia de voltaje, TX (transmisi\u00f3n) y RX (lectura) tambi\u00e9n usados para comunicaci\u00f3n serial, RESET para resetear, Vin para alimentar la placa y los pines ICSP para comunicaci\u00f3n SPI. Alimentaci\u00f3n: Como hemos visto el pin Vin sirve para alimentar la placa pero lo m\u00e1s normal es alimentarlo por el jack de alimentaci\u00f3n usando una tensi\u00f3n de 7 a 12 Voltios. Tambi\u00e9n podemos alimentarlo por el puerto USB pero en la mayor\u00eda de aplicaciones no lo tendremos conectado a un ordenador. Comunicaci\u00f3n: En nuestros tutoriales nos comunicaremos con Arduino mediante USB para cargar los programas o enviar/recibir datos. Sin embargo no es la \u00fanica forma que tiene Arduino de comunicarse. Cuando insertamos una shield \u00e9sta se comunica con nuestra placa utilizando los pines ICSP (comunicaci\u00f3n ISP), los pines 10 a 13 (tambi\u00e9n usados para comunicaci\u00f3n ISP), los pines TX/RX o cualquiera de los digitales ya que son capaces de configurarse como pines de entrada o salida y recibir o enviar pulsos digitales. Shields: traducido del ingl\u00e9s significa escudo. Se llama as\u00ed a las placas que se insertan sobre Arduino a modo de escudo ampliando sus posibilidades de uso. En el mercado existen infinidad de shields para cada tipo de Arduino. Algunas de las m\u00e1s comunes son las de Ethernet, Wi-Fi, Ultrasonidos, Pantallas LCD, rel\u00e9s, matrices LED's, GPS... Todo lo que necesitas para empezar Una de las primeras cosas que se pregunta uno antes de empezar en este mundo es si el equipo es demasiado caro. La respuesta es que no, todo lo contrario. Una placa Arduino Uno original cuesta 20,00\u20ac y lo pod\u00e9is pedir desde la propia web de Arduino . Tambi\u00e9n tenemos placas de otros fabricantes por unos 11\u20ac igualmente v\u00e1lidas gracias al car\u00e1cter hardware libre de esta plataforma. Si no ten\u00e9is prisa, desde China tambi\u00e9n las podemos encontrar por unos 5\u20ac , pero pueden tardar m\u00e1s de un mes en llegarnos. El entorno de programaci\u00f3n IDE es totalmente gratuito y podemos descargarlo pinchando aqu\u00ed . Es muy aconsejable una protoboard o placa de prototipos (breadboard en ingl\u00e9s) para realizar las pruebas y montajes. Suelen valer entre 5\u20ac y 10\u20ac . Tambi\u00e9n nos facilitar\u00e1 el trabajo un juego de cables con pines macho para insertar en Arduino y en la protoboard. No suelen costar m\u00e1s de 3\u20ac . Una alternativa es pelar cables y esta\u00f1arles las puntas para que no se deshilachen al meterlos en los agujeros. Las shield tienen precios muy dispares y van desde los 5\u20ac a 200\u20ac o m\u00e1s, pero en este tutorial no haremos uso de ninguna de ellas. Los componentes electr\u00f3nicos adicionales de cada proyecto, como pueden ser resistencias, condensadores, fotoresistencias, led's, zumbadores... tienen en su mayor\u00eda precios de pocos c\u00e9ntimos y rara vez superan el euro. En definitiva, por menos de 30\u20ac podemos hacernos con un equipo que nos permitir\u00e1 realizar multitud de proyectos. Esto es todo de momento. En el siguiente post encontrar\u00e1s toda la informaci\u00f3n para manejarte por el entorno de programaci\u00f3n de Arduino y ejecutar tu primer programa. Ver Indice Tutorial","title":"1. \u00bfQu\u00e9 es Arduino?"},{"location":"01_que_es_arduino/#que-es-arduino","text":"Arduino es una placa controladora y su entorno de programaci\u00f3n que permiten de manera r\u00e1pida y sencilla realizar proyectos de electr\u00f3nica, automatismo, control, dom\u00f3tica, etc. Arduino naci\u00f3 en el Instituto IVREA (Italia) para facilitar a sus alumnos las tareas de programaci\u00f3n de microcontroladores. Es ese uno de los motivos de su \u00e9xito: cualquier persona con pocos conocimientos de inform\u00e1tica y electr\u00f3nica puede programarlo e implementarlo. Existen varios modelos de Arduino como son Uno, Leonardo, Mega... pero este tutorial se limitar\u00e1 salvo que se diga lo contrario al modelo Uno por ser el m\u00e1s com\u00fan y econ\u00f3mico.","title":"\u00bfQu\u00e9 es Arduino?"},{"location":"01_que_es_arduino/#hardware-libre","text":"El otro motivo del gran \u00e9xito de esta plataforma podemos encontrarlo en que es desarrollado c\u00f3mo hardware libre . \u00bfqu\u00e9 es eso de hardware libre? Pues es lo an\u00e1logo al software libre . Sus esquemas, especificaciones y planos est\u00e1n disponibles al p\u00fablico, por tanto cualquiera que acceda a ellos puede fabricarse una copia id\u00e9ntica al original. Pero no s\u00f3lo eso, adem\u00e1s, cualquier usuario o fabricante puede crear accesorios compatibles con lo que las posibilidades de realizar nuevos proyectos se multiplican. Esto atrae nuevos usuarios, algunos de los cuales crean nuevos accesorios y tienen nuevas ideas con lo que estamos retroalimentando una comunidad de usuarios y fabricantes que no para de crecer.","title":"Hardware libre"},{"location":"01_que_es_arduino/#open-source-recursos","text":"Que es el Open Source explicado con Lego Que es el Software Libre segun Richard Stallman How Arduino is opensourcing imagination Qu\u00e9 es del movimiento maker , 10 a\u00f1os despu\u00e9s que fuese a cambiar el mundo","title":"Open Source (Recursos):"},{"location":"01_que_es_arduino/#pensamiento-computacional","text":"Que es el pensamiento computacional- Programamos Computational Thinking- Art\u00edculo Jeannette M. Wing","title":"Pensamiento Computacional:"},{"location":"01_que_es_arduino/#proyectos-educativos-open-source","text":"Escornabot : Escornabot es un proyecto de c\u00f3digo/hardware abierto cuyo objetivo es acercar la rob\u00f3tica y la programaci\u00f3n a los ni\u00f1os y ni\u00f1as. EchidnaShield : EchidnaShield es un proyecto Open Source dirigido a facilitar el aprendizaje de la programaci\u00f3n de sistemas f\u00edsicos en los \u00faltimos cursos de Primaria y en Secundaria Edub\u00e1sica : Escudo para Arduino y pr\u00e1cticas de programaci\u00f3n","title":"Proyectos educativos Open Source:"},{"location":"01_que_es_arduino/#para-que-sirve","text":"Si est\u00e1s leyendo esto seguramente es porque ya le has visto alguna aplicaci\u00f3n y te ha picado el gusanillo. Aqu\u00ed veremos algunas aplicaciones aunque las posibilidades son tantas como las que permite cualquier placa con microcontrolador: infinitas. En general, podemos decir que un microcontrolador se utiliza para ordenar una serie de acciones en funci\u00f3n de las entradas que le lleguen. Por ejemplo, encender un ventilador cuando la lectura de temperatura supere un cierto valor. Otras veces su tarea es realizar una serie de acciones sucesivamente sin hacer ninguna lectura. \u00c9ste caso ser\u00eda el de utilizar Arduino para encender alternativamente las luces de un sem\u00e1foro. Cuando acabes el tutorial seguro que se te ocurren decenas de proyectos que podr\u00e1s realizar.","title":"\u00bfPara qu\u00e9 sirve?"},{"location":"01_que_es_arduino/#partes-de-arduino","text":"En este apartado veremos las distintas partes que conformar nuestro Arduino como son entradas, salidas, alimentaci\u00f3n, comunicaci\u00f3n y shields. Entradas: son los pines de nuestra placa que podemos utilizar para hacer lecturas. En la placa Uno son los pines digitales (del 0 al 13) y los anal\u00f3gicos (del A0 al A5). Salidas: los pines de salidas se utilizan para el env\u00edo de se\u00f1ales. En este caso los pines de salida son s\u00f3lo los digitales (0 a 13). Otros pines: tambi\u00e9n tenemos otros pines como los GND (tierra), 5V que proporciona 5 Voltios, 3.3V que proporciona 3.3 Voltios, los pines REF de referencia de voltaje, TX (transmisi\u00f3n) y RX (lectura) tambi\u00e9n usados para comunicaci\u00f3n serial, RESET para resetear, Vin para alimentar la placa y los pines ICSP para comunicaci\u00f3n SPI. Alimentaci\u00f3n: Como hemos visto el pin Vin sirve para alimentar la placa pero lo m\u00e1s normal es alimentarlo por el jack de alimentaci\u00f3n usando una tensi\u00f3n de 7 a 12 Voltios. Tambi\u00e9n podemos alimentarlo por el puerto USB pero en la mayor\u00eda de aplicaciones no lo tendremos conectado a un ordenador. Comunicaci\u00f3n: En nuestros tutoriales nos comunicaremos con Arduino mediante USB para cargar los programas o enviar/recibir datos. Sin embargo no es la \u00fanica forma que tiene Arduino de comunicarse. Cuando insertamos una shield \u00e9sta se comunica con nuestra placa utilizando los pines ICSP (comunicaci\u00f3n ISP), los pines 10 a 13 (tambi\u00e9n usados para comunicaci\u00f3n ISP), los pines TX/RX o cualquiera de los digitales ya que son capaces de configurarse como pines de entrada o salida y recibir o enviar pulsos digitales. Shields: traducido del ingl\u00e9s significa escudo. Se llama as\u00ed a las placas que se insertan sobre Arduino a modo de escudo ampliando sus posibilidades de uso. En el mercado existen infinidad de shields para cada tipo de Arduino. Algunas de las m\u00e1s comunes son las de Ethernet, Wi-Fi, Ultrasonidos, Pantallas LCD, rel\u00e9s, matrices LED's, GPS...","title":"Partes de Arduino"},{"location":"01_que_es_arduino/#todo-lo-que-necesitas-para-empezar","text":"Una de las primeras cosas que se pregunta uno antes de empezar en este mundo es si el equipo es demasiado caro. La respuesta es que no, todo lo contrario. Una placa Arduino Uno original cuesta 20,00\u20ac y lo pod\u00e9is pedir desde la propia web de Arduino . Tambi\u00e9n tenemos placas de otros fabricantes por unos 11\u20ac igualmente v\u00e1lidas gracias al car\u00e1cter hardware libre de esta plataforma. Si no ten\u00e9is prisa, desde China tambi\u00e9n las podemos encontrar por unos 5\u20ac , pero pueden tardar m\u00e1s de un mes en llegarnos. El entorno de programaci\u00f3n IDE es totalmente gratuito y podemos descargarlo pinchando aqu\u00ed . Es muy aconsejable una protoboard o placa de prototipos (breadboard en ingl\u00e9s) para realizar las pruebas y montajes. Suelen valer entre 5\u20ac y 10\u20ac . Tambi\u00e9n nos facilitar\u00e1 el trabajo un juego de cables con pines macho para insertar en Arduino y en la protoboard. No suelen costar m\u00e1s de 3\u20ac . Una alternativa es pelar cables y esta\u00f1arles las puntas para que no se deshilachen al meterlos en los agujeros. Las shield tienen precios muy dispares y van desde los 5\u20ac a 200\u20ac o m\u00e1s, pero en este tutorial no haremos uso de ninguna de ellas. Los componentes electr\u00f3nicos adicionales de cada proyecto, como pueden ser resistencias, condensadores, fotoresistencias, led's, zumbadores... tienen en su mayor\u00eda precios de pocos c\u00e9ntimos y rara vez superan el euro. En definitiva, por menos de 30\u20ac podemos hacernos con un equipo que nos permitir\u00e1 realizar multitud de proyectos. Esto es todo de momento. En el siguiente post encontrar\u00e1s toda la informaci\u00f3n para manejarte por el entorno de programaci\u00f3n de Arduino y ejecutar tu primer programa. Ver Indice Tutorial","title":"Todo lo que necesitas para empezar"},{"location":"02_ide_arduino/","text":"\u00bfQu\u00e9 es y para qu\u00e9 sirve? Dado que el Arduino es como un peque\u00f1o ordenador que ejecuta una serie de c\u00f3digos que previamente le hemos introducido, necesitaremos un programa para poder meter estos c\u00f3digos a la propia placa. Este programa se llama IDE, que significa \"Integrated Development Environment\" (\"Entorno de Desarrollo Integrado\"). Este IDE estar\u00e1 instalado en nuestro PC, es un entorno muy sencillo de usar y en \u00e9l escribiremos el programa que queramos que el Arduino ejecute. Una vez escrito, lo cargaremos a trav\u00e9s del USB y Arduino comenzar\u00e1 a trabajar de forma aut\u00f3noma. Descarga e instalaci\u00f3n Para instalar este IDE en vuestro sistema operativo solo tendr\u00e9is que seguir unos sencillos pasos: Descargar el programa gratuito \"Arduino IDE\" de su propia p\u00e1gina web. Pod\u00e9is hacer clic en este enlace o dirig\u00edos en la web de Arduino a la secci\u00f3n de descargas . Hac\u00e9is clic en vuestro sistema operativo, despu\u00e9s en guardar archivo y lo descarg\u00e1is. Instalaci\u00f3n en Windows: (si vuestro sistema operativo es Linux pod\u00e9is saltar al siguiente punto) Una vez descargado lo ejecut\u00e1is y podr\u00e9is ver la siguiente ventana. Ilustraci\u00f3n 3 Aceptaci\u00f3n de condiciones. Pulsamos en \"I Agree\". En este cuadro dejamos todas las opciones marcadas, pero hay que prestar especial atenci\u00f3n a la opci\u00f3n de instalar los USB driver, ya que esto es muy importante para que la placa Arduino se pueda comunicar con el PC. Pulsamos en Next e Install. Ilustraci\u00f3n 4 Selecci\u00f3n de opciones de instalaci\u00f3n. Ilustraci\u00f3n 5 Selecci\u00f3n de carpeta de instalaci\u00f3n. Y esperaremos que termine de instalar (si pregunta si deseamos instalar el software Arduino USB le damos a instalar). Ilustraci\u00f3n 6 Proceso de instalaci\u00f3n. ![Imagen 5 en Tutorial Arduino: IDE Arduino](./img02/d73913f9ed06201a2659bbcaf3a36639.webp) Una vez terminado el proceso, hacemos clic en Close y ya tendremos el IDE instalado en nuestro PC. Instalaci\u00f3n en Linux Hay dos formas de hacerlo: A. En distribuciones como Ubuntu y derivados (Lubuntu, Linux Mint...) se puede instalar desde los repositorios al menos desde la versi\u00f3n de Ubuntu 14.04 (17 para Linux Mint) estando disponible Arduino-1.0.5. Para instalar, abrimos el Gestor de paquetes Synaptic o el Centro de Software y buscamos Arduino Ilustraci\u00f3n 7 Gestor de software de Linux Mint Pulsamos instalar y empezar\u00e1 el proceso de descarga e instalaci\u00f3n. B. Descargando e instalando el paquete desde la web de Arduino. Ilustraci\u00f3n 8 Apartado de descargas de Arduino Descargamos la versi\u00f3n 32 o 64 bits dependiendo del sistema operativo. Despu\u00e9s abrimos terminal y nos vamos a la carpeta donde lo hemos descargado. En nuestro caso lo descargamos en el Escritorio as\u00ed que usamos el comando \"cd Escritorio\". Ilustraci\u00f3n 9 Cambiando el directorio de trabajo Una vez que estemos en la carpeta donde lo hemos descargado, escribimos el comando \"tar -zxvf arduino-1.0.6-linux32.tgz\". (En general es \"tar -zxvf nombrearchivo.tgz\") Ilustraci\u00f3n 10 Cambiando el directorio de trabajo 2 Despu\u00e9s de pulsar intro, empieza la instalaci\u00f3n que dura pocos segundos. Al finalizar podemos comprobar que se ha creado un directorio llamado arduino1.0.6 (o versi\u00f3n descargada). Entramos y tenemos un ejecutable llamado \"arduino\" Ilustraci\u00f3n 11 Captura explorador de archivos Hacemos doble clic en ese archivo y, en la ventana que se abre, pulsamos \"Ejecutar\". Entorno de programaci\u00f3n y configuraci\u00f3n Al abrir el programa veremos c\u00f3mo nos aparece la consola principal del IDE Arduino en la cual podemos ver las siguientes zonas: Ilustraci\u00f3n 12 Zonas del IDE Arduino En la parte de men\u00fa tenemos una zona para acceder a funciones como carga de archivos, edici\u00f3n del texto del c\u00f3digo, carga de librer\u00edas y ejemplos, configuraci\u00f3n, herramientas\u2026etc. En los botones de acceso r\u00e1pido tenemos los siguientes iconos: Verifica si tu programa est\u00e1 bien escrito y puede funcionar. Carga el programa a la placa de Arduino tras compilarlo. Crea un programa nuevo. Abre un programa. Guarda el programa en el disco duro del ordenador. (En la parte derecha de la barra de herramientas se encuentra el Monitor Serial) abre una ventana de comunicaci\u00f3n con la placa Arduino en la que podemos ver las respuestas que nuestro Arduino nos est\u00e1 dando, siempre que tengamos el USB conectado. En el cuadro del editor de texto escribiremos el c\u00f3digo del programa que queramos que Arduino ejecute. Finalmente, en el \u00e1rea de mensajes y la consola Arduino nos ir\u00e1 dando informaci\u00f3n sobre si la consola est\u00e1 compilando, cargando\u2026y sobre los fallos o errores que se produzcan tanto en el c\u00f3digo como en el propio IDE. El siguiente paso que realizaremos ser\u00e1 configurar nuestro IDE para que se comunique con nuestra placa Arduino. Para ello conectaremos nuestro Arduino mediante el cable USB al PC y despu\u00e9s de que el sistema operativo haya reconocido e instalado la tarjeta autom\u00e1ticamente, nos dirigimos a la zona de men\u00fa , pulsamos en Herramientas y despu\u00e9s en Tarjeta . Ah\u00ed seleccionamos el modelo de tarjeta Arduino que tengamos, en nuestro caso \"Arduino Uno\". Ilustraci\u00f3n 13 Selecci\u00f3n de Tarjeta Despu\u00e9s vamos a la opci\u00f3n Puerto Serial y elegimos el COM en el que tenemos conectado nuestro Arduino. Ilustraci\u00f3n 14 Selecci\u00f3n de puerto COM Si nos aparecieran varios COM activos, porque estemos usando otros dispositivos serial o por otro motivo, para saber cu\u00e1l de ellos es el que se comunica con nuestra placa, solo tenemos que irnos a Panel de control/Hardware/Administrador de dispositivos. Miramos la pesta\u00f1a (Puertos COM y LPT) y ah\u00ed nos aparecer\u00e1 nuestro Arduino y el COM en el que est\u00e1 conectado. Con esto, ya podemos empezar a programar nuestro Arduino. Programa de testeo: \"HELLO WORLD\" Para finalizar, probaremos que todo est\u00e1 correctamente instalado y configurado ejecutando nuestro primer programa, el m\u00e1s simple, el t\u00edpico \"HELLO WORLD\" (\"HOLA MUNDO\"). Para ello solo ten\u00e9is que pegar el siguiente c\u00f3digo en la zona del editor de texto del IDE Arduino: ```c++ void setup() { Serial.begin(9600); // iniciamos el serial pinMode(13, OUTPUT); // se declara pin 13 como salida } void loop() { digitalWrite(13, HIGH); // se enciende el LED Serial.println(\"HOLA MUNDO\"); // Escribe por el monitor serial delay(1000); // espera 1 segundo digitalWrite(13, LOW); // se apaga el LED delay(1000); // espera 1 segundo } ``` Conectamos la placa Arduino al PC usando el cable USB y hacemos clic en el bot\u00f3n de cargar . Si hab\u00e9is seguido todo correctamente, podr\u00e9is ver c\u00f3mo el led de vuestro Arduino parpadea y si clic\u00e1is en el bot\u00f3n del monitor serial ver\u00e9is como Arduino os est\u00e1 escribiendo \"HOLA MUNDO\". Espero que os haya resultado f\u00e1cil. En el pr\u00f3ximo post veremos la estructura de un programa, las sentencias m\u00e1s comunes y realizareis vuestro primer ejemplo pr\u00e1ctico.","title":"2. El IDE de Arduino"},{"location":"02_ide_arduino/#que-es-y-para-que-sirve","text":"Dado que el Arduino es como un peque\u00f1o ordenador que ejecuta una serie de c\u00f3digos que previamente le hemos introducido, necesitaremos un programa para poder meter estos c\u00f3digos a la propia placa. Este programa se llama IDE, que significa \"Integrated Development Environment\" (\"Entorno de Desarrollo Integrado\"). Este IDE estar\u00e1 instalado en nuestro PC, es un entorno muy sencillo de usar y en \u00e9l escribiremos el programa que queramos que el Arduino ejecute. Una vez escrito, lo cargaremos a trav\u00e9s del USB y Arduino comenzar\u00e1 a trabajar de forma aut\u00f3noma.","title":"\u00bfQu\u00e9 es y para qu\u00e9 sirve?"},{"location":"02_ide_arduino/#descarga-e-instalacion","text":"Para instalar este IDE en vuestro sistema operativo solo tendr\u00e9is que seguir unos sencillos pasos: Descargar el programa gratuito \"Arduino IDE\" de su propia p\u00e1gina web. Pod\u00e9is hacer clic en este enlace o dirig\u00edos en la web de Arduino a la secci\u00f3n de descargas . Hac\u00e9is clic en vuestro sistema operativo, despu\u00e9s en guardar archivo y lo descarg\u00e1is. Instalaci\u00f3n en Windows: (si vuestro sistema operativo es Linux pod\u00e9is saltar al siguiente punto) Una vez descargado lo ejecut\u00e1is y podr\u00e9is ver la siguiente ventana. Ilustraci\u00f3n 3 Aceptaci\u00f3n de condiciones. Pulsamos en \"I Agree\". En este cuadro dejamos todas las opciones marcadas, pero hay que prestar especial atenci\u00f3n a la opci\u00f3n de instalar los USB driver, ya que esto es muy importante para que la placa Arduino se pueda comunicar con el PC. Pulsamos en Next e Install. Ilustraci\u00f3n 4 Selecci\u00f3n de opciones de instalaci\u00f3n. Ilustraci\u00f3n 5 Selecci\u00f3n de carpeta de instalaci\u00f3n. Y esperaremos que termine de instalar (si pregunta si deseamos instalar el software Arduino USB le damos a instalar). Ilustraci\u00f3n 6 Proceso de instalaci\u00f3n. ![Imagen 5 en Tutorial Arduino: IDE Arduino](./img02/d73913f9ed06201a2659bbcaf3a36639.webp) Una vez terminado el proceso, hacemos clic en Close y ya tendremos el IDE instalado en nuestro PC. Instalaci\u00f3n en Linux Hay dos formas de hacerlo: A. En distribuciones como Ubuntu y derivados (Lubuntu, Linux Mint...) se puede instalar desde los repositorios al menos desde la versi\u00f3n de Ubuntu 14.04 (17 para Linux Mint) estando disponible Arduino-1.0.5. Para instalar, abrimos el Gestor de paquetes Synaptic o el Centro de Software y buscamos Arduino Ilustraci\u00f3n 7 Gestor de software de Linux Mint Pulsamos instalar y empezar\u00e1 el proceso de descarga e instalaci\u00f3n. B. Descargando e instalando el paquete desde la web de Arduino. Ilustraci\u00f3n 8 Apartado de descargas de Arduino Descargamos la versi\u00f3n 32 o 64 bits dependiendo del sistema operativo. Despu\u00e9s abrimos terminal y nos vamos a la carpeta donde lo hemos descargado. En nuestro caso lo descargamos en el Escritorio as\u00ed que usamos el comando \"cd Escritorio\". Ilustraci\u00f3n 9 Cambiando el directorio de trabajo Una vez que estemos en la carpeta donde lo hemos descargado, escribimos el comando \"tar -zxvf arduino-1.0.6-linux32.tgz\". (En general es \"tar -zxvf nombrearchivo.tgz\") Ilustraci\u00f3n 10 Cambiando el directorio de trabajo 2 Despu\u00e9s de pulsar intro, empieza la instalaci\u00f3n que dura pocos segundos. Al finalizar podemos comprobar que se ha creado un directorio llamado arduino1.0.6 (o versi\u00f3n descargada). Entramos y tenemos un ejecutable llamado \"arduino\" Ilustraci\u00f3n 11 Captura explorador de archivos Hacemos doble clic en ese archivo y, en la ventana que se abre, pulsamos \"Ejecutar\". Entorno de programaci\u00f3n y configuraci\u00f3n Al abrir el programa veremos c\u00f3mo nos aparece la consola principal del IDE Arduino en la cual podemos ver las siguientes zonas: Ilustraci\u00f3n 12 Zonas del IDE Arduino En la parte de men\u00fa tenemos una zona para acceder a funciones como carga de archivos, edici\u00f3n del texto del c\u00f3digo, carga de librer\u00edas y ejemplos, configuraci\u00f3n, herramientas\u2026etc. En los botones de acceso r\u00e1pido tenemos los siguientes iconos: Verifica si tu programa est\u00e1 bien escrito y puede funcionar. Carga el programa a la placa de Arduino tras compilarlo. Crea un programa nuevo. Abre un programa. Guarda el programa en el disco duro del ordenador. (En la parte derecha de la barra de herramientas se encuentra el Monitor Serial) abre una ventana de comunicaci\u00f3n con la placa Arduino en la que podemos ver las respuestas que nuestro Arduino nos est\u00e1 dando, siempre que tengamos el USB conectado. En el cuadro del editor de texto escribiremos el c\u00f3digo del programa que queramos que Arduino ejecute. Finalmente, en el \u00e1rea de mensajes y la consola Arduino nos ir\u00e1 dando informaci\u00f3n sobre si la consola est\u00e1 compilando, cargando\u2026y sobre los fallos o errores que se produzcan tanto en el c\u00f3digo como en el propio IDE. El siguiente paso que realizaremos ser\u00e1 configurar nuestro IDE para que se comunique con nuestra placa Arduino. Para ello conectaremos nuestro Arduino mediante el cable USB al PC y despu\u00e9s de que el sistema operativo haya reconocido e instalado la tarjeta autom\u00e1ticamente, nos dirigimos a la zona de men\u00fa , pulsamos en Herramientas y despu\u00e9s en Tarjeta . Ah\u00ed seleccionamos el modelo de tarjeta Arduino que tengamos, en nuestro caso \"Arduino Uno\". Ilustraci\u00f3n 13 Selecci\u00f3n de Tarjeta Despu\u00e9s vamos a la opci\u00f3n Puerto Serial y elegimos el COM en el que tenemos conectado nuestro Arduino. Ilustraci\u00f3n 14 Selecci\u00f3n de puerto COM Si nos aparecieran varios COM activos, porque estemos usando otros dispositivos serial o por otro motivo, para saber cu\u00e1l de ellos es el que se comunica con nuestra placa, solo tenemos que irnos a Panel de control/Hardware/Administrador de dispositivos. Miramos la pesta\u00f1a (Puertos COM y LPT) y ah\u00ed nos aparecer\u00e1 nuestro Arduino y el COM en el que est\u00e1 conectado. Con esto, ya podemos empezar a programar nuestro Arduino. Programa de testeo: \"HELLO WORLD\" Para finalizar, probaremos que todo est\u00e1 correctamente instalado y configurado ejecutando nuestro primer programa, el m\u00e1s simple, el t\u00edpico \"HELLO WORLD\" (\"HOLA MUNDO\"). Para ello solo ten\u00e9is que pegar el siguiente c\u00f3digo en la zona del editor de texto del IDE Arduino: ```c++ void setup() { Serial.begin(9600); // iniciamos el serial pinMode(13, OUTPUT); // se declara pin 13 como salida } void loop() { digitalWrite(13, HIGH); // se enciende el LED Serial.println(\"HOLA MUNDO\"); // Escribe por el monitor serial delay(1000); // espera 1 segundo digitalWrite(13, LOW); // se apaga el LED delay(1000); // espera 1 segundo } ``` Conectamos la placa Arduino al PC usando el cable USB y hacemos clic en el bot\u00f3n de cargar . Si hab\u00e9is seguido todo correctamente, podr\u00e9is ver c\u00f3mo el led de vuestro Arduino parpadea y si clic\u00e1is en el bot\u00f3n del monitor serial ver\u00e9is como Arduino os est\u00e1 escribiendo \"HOLA MUNDO\". Espero que os haya resultado f\u00e1cil. En el pr\u00f3ximo post veremos la estructura de un programa, las sentencias m\u00e1s comunes y realizareis vuestro primer ejemplo pr\u00e1ctico.","title":"Descarga e instalaci\u00f3n"},{"location":"03_ejemplo_semaforo/","text":"En este nuevo post daremos unas pautas sobre c\u00f3mo debe estructurar un programa en Arduino, tambi\u00e9n veremos c\u00f3mo son las sentencias b\u00e1sicas usadas con esta IDE, c\u00f3mo cargar nuestro programa a la placa y para finalizar, realizaremos un ejemplo con el que encenderemos leds con Arduino montando nuestro propio sem\u00e1foro. Aprovecho para recomendarte que comiences nuestro Curso de Arduino para avanzar m\u00e1s en este apasionante mundo. Estructura b\u00e1sica de los c\u00f3digos Un c\u00f3digo Arduino es una serie de comandos de programaci\u00f3n que le dir\u00e1n a nuestro microcontrolador como configurarse al iniciarse y qu\u00e9 acciones tiene que realizar mientras est\u00e9 en funcionamiento. Estos comandos utilizados en Arduino son sentencias muy f\u00e1ciles e intuitivas. El bloque de c\u00f3digo debe tener 2 partes, o funciones principales, que siempre debemos incluir. Partes b\u00e1sicas de un c\u00f3digo Primero void setup() . Dentro de esta funci\u00f3n principal escribiremos las sentencias de configuraci\u00f3n que necesitaremos para que Arduino trabaje correctamente. \u00c9stas se ejecutar\u00e1n al iniciar Arduino y una \u00fanica vez. Con ellas, por ejemplo, asignaremos la caracter\u00edstica de entrada/salida a los pines, el modo de comunicaci\u00f3n serial, activaremos los sensores que vayamos a necesitar, escribiremos \u00f3rdenes de inicio del programa\u2026etc. Algunas de estas sentencias pueden ser: pinMode( , ), Serial.begin(,), sensors.begin(,)\u2026 La segunda funci\u00f3n principal es void loop() . \u00c9sta debe ir siempre despu\u00e9s de void setup(). En ella escribiremos todas las sentencias, bucles y llamadas a funciones que necesitemos que nuestro Arduino repita constantemente. Se escribir\u00e1n en orden de ejecuci\u00f3n. Ejemplo de \u00e9stas pueden ser digitalWrite( , ), Serial.print(\u201c \u201c), if( )\u2026 Existen otras partes del c\u00f3digo que no son obligatorias pero que podemos necesitar, seg\u00fan el c\u00f3digo lo requiera, para organizarlo todo. Estas zonas pueden ser un espacio para el t\u00edtulo, el autor, librer\u00edas, definiciones (variables que vayamos a usar en el programa), una zona para funciones a las que el programa ir\u00e1 llamando\u2026Cada uno es libre de organizarlo como quiera, pero cuanto m\u00e1s ordenado est\u00e9 todo, m\u00e1s dif\u00edcil ser\u00e1 perdernos cuando los c\u00f3digos se compliquen. Abajo podemos ver un ejemplo simple de c\u00f3mo debe estructurarse un c\u00f3digo. C\u00f3mo debe estructurarse un c\u00f3digo Sentencias b\u00e1sicas, funciones y librer\u00edas Para poder realizar un c\u00f3digo Arduino debemos tener las herramientas con las que decirle a nuestro microcontrolador que es lo que debe hacer en cada momento. Estas herramientas son las sentencias y funciones . Arduino usa una serie de sentencias y comandos b\u00e1sicos muy sencillitos pero a la vez muy potentes. Combin\u00e1ndolos crearemos programas para decirle a nuestra placa que haga pr\u00e1cticamente cualquier cosa que queramos. Las sentencias se dividen por su manera de funcionar dentro del programa, pudiendo dividirlas en 3 grandes grupos: Estructurales : Nos dan la forma computacional del c\u00f3digo y las operaciones l\u00f3gicas a ejecutar. Con \u00e9stos son con los que le marcamos al programa qu\u00e9 camino debe seguir el c\u00f3digo al ejecutarse y qu\u00e9 operaciones debe hacer. Alg\u00fan ejemplo de las m\u00e1s usadas son if, for, while, +, -, =, *, /, ==, >, < \u2026 Variables : Con \u00e9stas definiremos qu\u00e9 tipo y qu\u00e9 caracter\u00edsticas tendr\u00e1n los valores que vamos a usar en el c\u00f3digo. Pueden ser n\u00fameros, caracteres o estados. Podemos encontrarnos aqu\u00ed las sentencias int, float, HIGH, LOW, char, string, true, false\u2026 Funciones : Nos permiten realizar una serie de operaciones concretas y volver a la zona del c\u00f3digo en la que se ejecut\u00f3. Existen funciones que est\u00e1n propiamente definidas ya por Arduino como tales y tambi\u00e9n podemos crearnos nuestras propias funciones para que sean llamadas en las zonas de setup o loop cuando lo necesitemos. Son muy \u00fatiles cuando necesitamos realizar un grupo de acciones varias veces en distintas zonas del c\u00f3digo. Tambi\u00e9n es una buena forma de ahorrar l\u00edneas y de organizarse. Ejemplo de funciones tenemos pinMode, digitalWrite, delay, max, sin, cos, analogWrite\u2026 Como explicar qu\u00e9 acci\u00f3n concreta realiza cada sentencia o funci\u00f3n ser\u00eda muy extenso, os dejamos este enlace para que pod\u00e1is consultarlos. Nosotros iremos comentando todos los que vayamos usando en nuestros ejemplos. Otra cosa importante son las librer\u00edas . Son una serie de sentencias y funciones espec\u00edficas de cada elemento o shield que conectemos a Arduino, que no est\u00e1n dentro de las propias de la IDE, y que realizar\u00e1n acciones espec\u00edficas de cada uno facilit\u00e1ndonos mucho la programaci\u00f3n. Por \u00faltimo nombraremos un par de peque\u00f1os detalles necesarios para poder programar nuestro c\u00f3digo. Para que cada sentencia o funci\u00f3n se ejecute debe llevar al final de cada orden el signo de puntuaci\u00f3n punto y coma \u201c ; \u201c y al utilizar la doble barra \u201c // \u201d le decimos al c\u00f3digo que lo que se escriba a la derecha es un comentario y que no debe ejecutarlo (Arduino lo colorear\u00e1 en gris). Esto ver\u00e9is que es muy \u00fatil para explicar que estamos haciendo en cada momento. Compilaci\u00f3n y carga. Una vez que hayamos escrito nuestro c\u00f3digo en la IDE Arduino procederemos a verificar que est\u00e1 correctamente escrito. Para ello pulsamos el bot\u00f3n arriba a la izquierda. Arduino leer\u00e1 el texto y nos dir\u00e1 si es correcto o no. Para ello lo que har\u00e1 ser\u00e1 compilarlo, que significa traducir el c\u00f3digo del lenguaje de programaci\u00f3n a un lenguaje que entienda el microcontrolador directamente. En el caso de contener un error nos aparecer\u00e1 en la consola una explicaci\u00f3n orientativa del error. Verificando el c\u00f3digo C\u00f3digo correcto Error en el c\u00f3digo. Falta un \";\" Si la compilaci\u00f3n ha sido correcta, ya podremos cargar nuestro programa al Arduino. Para ello, con la placa conectada por USB, pulsamos el bot\u00f3n de carga y esperamos a que termine. Carga de programa terminada Ejemplo: Sem\u00e1foro Como primer proyecto, realizaremos un sem\u00e1foro con unos Leds. Es ideal para iniciarnos en la programaci\u00f3n y el montaje de circuitos porque, como ver\u00e9is, es muy f\u00e1cil. Empezaremos nuestro primer proyecto describiendo los elementos que vamos a necesitar. 1 x Arduino UNO R3 1 x Protoboard 1 x Led rojo 3mm 1 x Led amarillo 3mm 1 x Led verde 3mm 3 x resistencias de 220\u03a9. Cables para conectar todo. Una vez que tenemos todo, hacemos nuestro montaje siguiendo el siguiente esquema. Esquema de montaje del sem\u00e1foro Utilizaremos los pines digitales 2 (rojo), 4 (amarillo) y 7 (verde). Al conectar los Leds deb\u00e9is tener en cuenta que tienen polaridad, por lo que ten\u00e9is que colocarlos bien para que funcionen. En los Leds la patilla corta, o el lado que est\u00e1 achatado, es el negativo e ir\u00e1 conectado a tierra (GND en la placa) a trav\u00e9s de una resistencia. La patilla larga, o lado redondeado, es el positivo y se conectar\u00e1 al pin del Arduino correspondiente. Protoboard del proyecto sem\u00e1foro Una vez montado, abriremos nuestro IDE Arduino y escribiremos el programa ( sketch ). /*************/ /* SEMAFORO */ /*************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int rojo=2; //definimos el valor del pin para el led rojo int amarillo=4; //definimos el valor del pin para el led amarillo int verde=7; //definimos el valor del pin para el led verde //** Programa **// void setup() { pinMode(verde,OUTPUT); //declaramos el pin verde como salida pinMode(amarillo,OUTPUT);//declaramos el pin amarillo como salida pinMode(rojo,OUTPUT); //declaramos el pin rojo como salida } void loop() { digitalWrite(verde,HIGH); //encendemos el led rojo delay(2000); //esperamos 2 segundos digitalWrite(verde,LOW); //apagamos el led rojo delay(500); //esperamos medio segundo digitalWrite(amarillo,HIGH); //encendemos el led amarillo delay(2000); //esperamos 2 segundos digitalWrite(amarillo,LOW); //apagamos el led amarillo delay(500); //esperamos medio segundo digitalWrite(rojo,HIGH); //encendemos el led verde delay(2000); //esperamos 2 segundos digitalWrite(rojo,LOW); //apagamos el led verde delay(500); //esperamos medio segundo } Con la sentencia int estamos declarando una variable num\u00e9rica entera, para poderla usar despu\u00e9s en nuestro c\u00f3digo. El comando delay hace que el programa pare un tiempo determinado. \u00c9ste lo definiremos, en milisegundos, dentro de los par\u00e9ntesis. Las funciones pinMode y digitalWrite se explicar\u00e1n en el siguiente post, salidas , con detalle. Espero que os hay\u00e1is divertido con este post y que comenc\u00e9is a cogerle el gusanillo al mundo del Arduino.","title":"3. Ejemplo.- Sem\u00e1foro"},{"location":"03_ejemplo_semaforo/#sentencias-basicas-funciones-y-librerias","text":"Para poder realizar un c\u00f3digo Arduino debemos tener las herramientas con las que decirle a nuestro microcontrolador que es lo que debe hacer en cada momento. Estas herramientas son las sentencias y funciones . Arduino usa una serie de sentencias y comandos b\u00e1sicos muy sencillitos pero a la vez muy potentes. Combin\u00e1ndolos crearemos programas para decirle a nuestra placa que haga pr\u00e1cticamente cualquier cosa que queramos. Las sentencias se dividen por su manera de funcionar dentro del programa, pudiendo dividirlas en 3 grandes grupos: Estructurales : Nos dan la forma computacional del c\u00f3digo y las operaciones l\u00f3gicas a ejecutar. Con \u00e9stos son con los que le marcamos al programa qu\u00e9 camino debe seguir el c\u00f3digo al ejecutarse y qu\u00e9 operaciones debe hacer. Alg\u00fan ejemplo de las m\u00e1s usadas son if, for, while, +, -, =, *, /, ==, >, < \u2026 Variables : Con \u00e9stas definiremos qu\u00e9 tipo y qu\u00e9 caracter\u00edsticas tendr\u00e1n los valores que vamos a usar en el c\u00f3digo. Pueden ser n\u00fameros, caracteres o estados. Podemos encontrarnos aqu\u00ed las sentencias int, float, HIGH, LOW, char, string, true, false\u2026 Funciones : Nos permiten realizar una serie de operaciones concretas y volver a la zona del c\u00f3digo en la que se ejecut\u00f3. Existen funciones que est\u00e1n propiamente definidas ya por Arduino como tales y tambi\u00e9n podemos crearnos nuestras propias funciones para que sean llamadas en las zonas de setup o loop cuando lo necesitemos. Son muy \u00fatiles cuando necesitamos realizar un grupo de acciones varias veces en distintas zonas del c\u00f3digo. Tambi\u00e9n es una buena forma de ahorrar l\u00edneas y de organizarse. Ejemplo de funciones tenemos pinMode, digitalWrite, delay, max, sin, cos, analogWrite\u2026 Como explicar qu\u00e9 acci\u00f3n concreta realiza cada sentencia o funci\u00f3n ser\u00eda muy extenso, os dejamos este enlace para que pod\u00e1is consultarlos. Nosotros iremos comentando todos los que vayamos usando en nuestros ejemplos. Otra cosa importante son las librer\u00edas . Son una serie de sentencias y funciones espec\u00edficas de cada elemento o shield que conectemos a Arduino, que no est\u00e1n dentro de las propias de la IDE, y que realizar\u00e1n acciones espec\u00edficas de cada uno facilit\u00e1ndonos mucho la programaci\u00f3n. Por \u00faltimo nombraremos un par de peque\u00f1os detalles necesarios para poder programar nuestro c\u00f3digo. Para que cada sentencia o funci\u00f3n se ejecute debe llevar al final de cada orden el signo de puntuaci\u00f3n punto y coma \u201c ; \u201c y al utilizar la doble barra \u201c // \u201d le decimos al c\u00f3digo que lo que se escriba a la derecha es un comentario y que no debe ejecutarlo (Arduino lo colorear\u00e1 en gris). Esto ver\u00e9is que es muy \u00fatil para explicar que estamos haciendo en cada momento.","title":"Sentencias b\u00e1sicas, funciones y librer\u00edas"},{"location":"03_ejemplo_semaforo/#compilacion-y-carga","text":"Una vez que hayamos escrito nuestro c\u00f3digo en la IDE Arduino procederemos a verificar que est\u00e1 correctamente escrito. Para ello pulsamos el bot\u00f3n arriba a la izquierda. Arduino leer\u00e1 el texto y nos dir\u00e1 si es correcto o no. Para ello lo que har\u00e1 ser\u00e1 compilarlo, que significa traducir el c\u00f3digo del lenguaje de programaci\u00f3n a un lenguaje que entienda el microcontrolador directamente. En el caso de contener un error nos aparecer\u00e1 en la consola una explicaci\u00f3n orientativa del error. Verificando el c\u00f3digo C\u00f3digo correcto Error en el c\u00f3digo. Falta un \";\" Si la compilaci\u00f3n ha sido correcta, ya podremos cargar nuestro programa al Arduino. Para ello, con la placa conectada por USB, pulsamos el bot\u00f3n de carga y esperamos a que termine. Carga de programa terminada","title":"Compilaci\u00f3n y carga."},{"location":"03_ejemplo_semaforo/#ejemplo-semaforo","text":"Como primer proyecto, realizaremos un sem\u00e1foro con unos Leds. Es ideal para iniciarnos en la programaci\u00f3n y el montaje de circuitos porque, como ver\u00e9is, es muy f\u00e1cil. Empezaremos nuestro primer proyecto describiendo los elementos que vamos a necesitar. 1 x Arduino UNO R3 1 x Protoboard 1 x Led rojo 3mm 1 x Led amarillo 3mm 1 x Led verde 3mm 3 x resistencias de 220\u03a9. Cables para conectar todo. Una vez que tenemos todo, hacemos nuestro montaje siguiendo el siguiente esquema. Esquema de montaje del sem\u00e1foro Utilizaremos los pines digitales 2 (rojo), 4 (amarillo) y 7 (verde). Al conectar los Leds deb\u00e9is tener en cuenta que tienen polaridad, por lo que ten\u00e9is que colocarlos bien para que funcionen. En los Leds la patilla corta, o el lado que est\u00e1 achatado, es el negativo e ir\u00e1 conectado a tierra (GND en la placa) a trav\u00e9s de una resistencia. La patilla larga, o lado redondeado, es el positivo y se conectar\u00e1 al pin del Arduino correspondiente. Protoboard del proyecto sem\u00e1foro Una vez montado, abriremos nuestro IDE Arduino y escribiremos el programa ( sketch ). /*************/ /* SEMAFORO */ /*************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int rojo=2; //definimos el valor del pin para el led rojo int amarillo=4; //definimos el valor del pin para el led amarillo int verde=7; //definimos el valor del pin para el led verde //** Programa **// void setup() { pinMode(verde,OUTPUT); //declaramos el pin verde como salida pinMode(amarillo,OUTPUT);//declaramos el pin amarillo como salida pinMode(rojo,OUTPUT); //declaramos el pin rojo como salida } void loop() { digitalWrite(verde,HIGH); //encendemos el led rojo delay(2000); //esperamos 2 segundos digitalWrite(verde,LOW); //apagamos el led rojo delay(500); //esperamos medio segundo digitalWrite(amarillo,HIGH); //encendemos el led amarillo delay(2000); //esperamos 2 segundos digitalWrite(amarillo,LOW); //apagamos el led amarillo delay(500); //esperamos medio segundo digitalWrite(rojo,HIGH); //encendemos el led verde delay(2000); //esperamos 2 segundos digitalWrite(rojo,LOW); //apagamos el led verde delay(500); //esperamos medio segundo } Con la sentencia int estamos declarando una variable num\u00e9rica entera, para poderla usar despu\u00e9s en nuestro c\u00f3digo. El comando delay hace que el programa pare un tiempo determinado. \u00c9ste lo definiremos, en milisegundos, dentro de los par\u00e9ntesis. Las funciones pinMode y digitalWrite se explicar\u00e1n en el siguiente post, salidas , con detalle. Espero que os hay\u00e1is divertido con este post y que comenc\u00e9is a cogerle el gusanillo al mundo del Arduino.","title":"Ejemplo: Sem\u00e1foro"},{"location":"04_salidas/","text":"Pines de salida Arduino utiliza sus pines de salida para enviar se\u00f1ales el\u00e9ctricas. \u00c9stas se\u00f1ales pueden utilizarse para alimentar otros dispositivos (led's, zumbadores...) o para comunicarse enviando una serie de pulsos que el receptor debe entender. Las salidas se dividen en dos niveles o estados: HIGH a 5 V y LOW a 0 V. Por defecto, y sin ning\u00fan programa cargado en nuestra tarjeta controladora, las salidas est\u00e1n a nivel LOW. Para valores intermedios veremos los pines con funci\u00f3n PWM en el punto 2. Para valores constantes de 5V, 3.3V y 0V (GND) podemos utilizar los pines correspondientes del apartado \u201cPOWER\u201d de nuestro Arduino. Configuraci\u00f3n y uso de las salidas digitales Los pines que podemos configurar para que cambien el nivel de salida seg\u00fan nuestro programa son los digitales, es decir, los 1 a 13. En realidad existen otros pines digitales pero no ser\u00e1n tratados en este tutorial. Por defecto estos pines est\u00e1n configurados como entradas as\u00ed que lo primero que tenemos que hacer para utilizar un pin como salida es configurarlo como tal. Para ello escribimos esta sentencia dentro del apartado setup del programa. pinMode(pin,OUTPUT); Donde sustituiremos \"pin\" por el n\u00famero del pin que queremos configurar como salida. Tambi\u00e9n podemos almacenar el n\u00famero de ese pin en una variable, por ejemplo el pin 10 en la variable llamada \"pinsalida\" y escribirla dentro de la funci\u00f3n pinMode . int pinsalida = 10; // almacena el n\u00famero 10 en la variable \"pinsalida\" pinMode(pinsalida,OUTPUT); // configura el pin n\u00famero \"pinsalida\" (10) como salida Ahora ya lo tenemos configurado como salida pero a\u00fan sigue a 0 V, es decir, a nivel LOW. Cuando en un determinado momento del programa queramos que ese pin se ponga a nivel HIGH escribiremos esta sentencia digitalWrite(pinsalida,HIGH); Ahora tendremos 5 V permanentemente en ese pin a no ser que en el programa insertemos digitalWrite(pinsalida,LOW); en cuyo caso se volver\u00e1 al valor de 0 V. Podemos poner los pines a HIGH o LOW tantas veces como queramos. IMPORTANTE : hay que tener en cuenta que estos pines tienen una intensidad limitada a 40 mA , por tanto no ser\u00e1 suficiente para alimentar a algunos rel\u00e9s, motores, bombillas y todo aquello que necesite mayor corriente. En otros post veremos c\u00f3mo solucionamos este \"problema\". PWM La funci\u00f3n PWD nos permite obtener valores intermedios de salidas entre 0 y 5V escalados en en 255 niveles, siendo 0 el m\u00e1s bajo (0 V) y 255 el m\u00e1s alto (5 V). Lo que en realidad sucede es que el microcontrolador alterna rapid\u00edsimamente estados HIGH y LOW un tiempo proporcional al valor requerido. As\u00ed, con 127 estar\u00eda el 50% del tiempo a HIGH y el otro 50% restante a LOW. Nosotros no lo notamos porque todo ello sucede a una frecuencia superior a la que captan nuestros ojos. Los pines que permiten esta funci\u00f3n est\u00e1n se\u00f1alados con el s\u00edmbolo ~ . En la placa Uno son los pines 3, 5, 6, 9, 10 y 11. Si como vimos en en anterior apartado ya tenemos nuestro pin configurado como salida, para obtener un nivel de salida de 75% escribiremos en nuestro programa analogWrite(pinsalida,191); Ya que 191 es el 75% de 255. Ejemplo funci\u00f3n PWM con LED Este ejemplo consta de dos partes. Primero un led se encender\u00e1 durante dos segundos. Luego variar\u00e1 su intensidad entre los valores m\u00e1ximo y m\u00ednimo gradualmente. Para conseguirlo utilizaremos uno de los pines PWM. El montaje es de lo m\u00e1s sencillo. Insertamos el led en la protoboard. Para no da\u00f1ar el led ponemos en serie una resistencia de unos 220-470 Ohmios. Con valores menores se corre el riesgo de da\u00f1arlo y valores mayores aten\u00faan demasiado el brillo. Seguidamente unimos mediante cables el pin 10 con la fila del \u00e1nodo (pata larga) y el GND con la fila del extremo libre de la resistencia. Si el led tiene las patas iguales, una forma de distinguir el c\u00e1todo del \u00e1nodo es fij\u00e1ndose en el borde del led que no es completamente circular. Pues la parte biselada corresponde al c\u00e1todo. Ahora vamos con el programa. En la primera parte declaramos las variables. int pinsalida = 10; // variable para guardar el n\u00famero del pin int velocidad = 100; // variable para cambiar la velocidad de encendido/apagado int pwm; // variable que almacenar\u00e1 el valor entre 0 y 255 Cambiando el valor de la variable velocidad haremos que el led tarde m\u00e1s o menos tiempo en completar los ciclos de cambio de intensidad. En la funci\u00f3n setup hacemos que el led se encienda 2 segundos y luego se apague. void setup() { pinMode(pinsalida,OUTPUT); // configura \"pinsalida\" como salida digitalWrite(pinsalida,HIGH); // pone el \"pinsalida\" a nivel alto delay(2000); // espera 2000 milisegundos (2 segundos) pinMode(pinsalida,LOW); // pon \"pinsalida a nivel bajo delay(1000); // espera 1 segundo } En la funci\u00f3n loop hacemos uso del PWM. Escribimos un bucle for que dar\u00e1 a la variable pwm un valor inicial de 0 y lo ir\u00e1 incrementando en una unidad hasta que alcance el valor m\u00e1ximo de 255. A continuaci\u00f3n ponemos otro bucle for que ir\u00e1 decrementando el valor desde el m\u00e1ximo hasta el m\u00ednimo. void loop() { for(pwm=0;pwm<256;pwm++) // desde pwm valiendo 0; hasta que valga 255; incrementa pwm { analogWrite(pinsalida,pwm); // pone el \"pinsalida\" a el valor que almacena la variable \"pwm\" delay(1000/velocidad); // espera (1000/velocidad) milisegundos } for(pwm=255;pwm>-1;pwm--) // este bucle hace lo mismo pero decrementando pwm { analogWrite(pinsalida,pwm); delay(1000/velocidad); } } El programa entero quedar\u00eda as\u00ed. /***********************/ /* ejemplo led pwm */ /***********************/ int pinsalida = 10; // variable para guardar el n\u00famero del pin int velocidad = 100; // variable para cambiar la velocidad de encendido/apagado int pwm; // variable que almacenar\u00e1 el valor entre 0 y 255 void setup() { pinMode(pinsalida,OUTPUT); // configura \"pinsalida\" como salida digitalWrite(pinsalida,HIGH); // pone el \"pinsalida\" a nivel alto delay(2000); // espera 2000 milisegundos (2 segundos) pinMode(pinsalida,LOW); // pon \"pinsalida a nivel bajo delay(1000); // espera 1 segundo } void loop() { for(pwm=0;pwm<256;pwm++) // desde pwm valiendo 0; hasta que valga 255; incrementa pwm { analogWrite(pinsalida,pwm); // pone el \"pinsalida\" a el valor que almacena la variable \"pwm\" delay(1000/velocidad); // espera (1000/velocidad) milisegundos } for(pwm=255;pwm>-1;pwm--) // este bucle hace lo mismo pero decrementando pwm { analogWrite(pinsalida,pwm); delay(1000/velocidad); } }","title":"04 salidas"},{"location":"04_salidas/#pines-de-salida","text":"Arduino utiliza sus pines de salida para enviar se\u00f1ales el\u00e9ctricas. \u00c9stas se\u00f1ales pueden utilizarse para alimentar otros dispositivos (led's, zumbadores...) o para comunicarse enviando una serie de pulsos que el receptor debe entender. Las salidas se dividen en dos niveles o estados: HIGH a 5 V y LOW a 0 V. Por defecto, y sin ning\u00fan programa cargado en nuestra tarjeta controladora, las salidas est\u00e1n a nivel LOW. Para valores intermedios veremos los pines con funci\u00f3n PWM en el punto 2. Para valores constantes de 5V, 3.3V y 0V (GND) podemos utilizar los pines correspondientes del apartado \u201cPOWER\u201d de nuestro Arduino.","title":"Pines de salida"},{"location":"04_salidas/#configuracion-y-uso-de-las-salidas-digitales","text":"Los pines que podemos configurar para que cambien el nivel de salida seg\u00fan nuestro programa son los digitales, es decir, los 1 a 13. En realidad existen otros pines digitales pero no ser\u00e1n tratados en este tutorial. Por defecto estos pines est\u00e1n configurados como entradas as\u00ed que lo primero que tenemos que hacer para utilizar un pin como salida es configurarlo como tal. Para ello escribimos esta sentencia dentro del apartado setup del programa. pinMode(pin,OUTPUT); Donde sustituiremos \"pin\" por el n\u00famero del pin que queremos configurar como salida. Tambi\u00e9n podemos almacenar el n\u00famero de ese pin en una variable, por ejemplo el pin 10 en la variable llamada \"pinsalida\" y escribirla dentro de la funci\u00f3n pinMode . int pinsalida = 10; // almacena el n\u00famero 10 en la variable \"pinsalida\" pinMode(pinsalida,OUTPUT); // configura el pin n\u00famero \"pinsalida\" (10) como salida Ahora ya lo tenemos configurado como salida pero a\u00fan sigue a 0 V, es decir, a nivel LOW. Cuando en un determinado momento del programa queramos que ese pin se ponga a nivel HIGH escribiremos esta sentencia digitalWrite(pinsalida,HIGH); Ahora tendremos 5 V permanentemente en ese pin a no ser que en el programa insertemos digitalWrite(pinsalida,LOW); en cuyo caso se volver\u00e1 al valor de 0 V. Podemos poner los pines a HIGH o LOW tantas veces como queramos. IMPORTANTE : hay que tener en cuenta que estos pines tienen una intensidad limitada a 40 mA , por tanto no ser\u00e1 suficiente para alimentar a algunos rel\u00e9s, motores, bombillas y todo aquello que necesite mayor corriente. En otros post veremos c\u00f3mo solucionamos este \"problema\".","title":"Configuraci\u00f3n y uso de las salidas digitales"},{"location":"04_salidas/#pwm","text":"La funci\u00f3n PWD nos permite obtener valores intermedios de salidas entre 0 y 5V escalados en en 255 niveles, siendo 0 el m\u00e1s bajo (0 V) y 255 el m\u00e1s alto (5 V). Lo que en realidad sucede es que el microcontrolador alterna rapid\u00edsimamente estados HIGH y LOW un tiempo proporcional al valor requerido. As\u00ed, con 127 estar\u00eda el 50% del tiempo a HIGH y el otro 50% restante a LOW. Nosotros no lo notamos porque todo ello sucede a una frecuencia superior a la que captan nuestros ojos. Los pines que permiten esta funci\u00f3n est\u00e1n se\u00f1alados con el s\u00edmbolo ~ . En la placa Uno son los pines 3, 5, 6, 9, 10 y 11. Si como vimos en en anterior apartado ya tenemos nuestro pin configurado como salida, para obtener un nivel de salida de 75% escribiremos en nuestro programa analogWrite(pinsalida,191); Ya que 191 es el 75% de 255.","title":"PWM"},{"location":"04_salidas/#ejemplo-funcion-pwm-con-led","text":"Este ejemplo consta de dos partes. Primero un led se encender\u00e1 durante dos segundos. Luego variar\u00e1 su intensidad entre los valores m\u00e1ximo y m\u00ednimo gradualmente. Para conseguirlo utilizaremos uno de los pines PWM. El montaje es de lo m\u00e1s sencillo. Insertamos el led en la protoboard. Para no da\u00f1ar el led ponemos en serie una resistencia de unos 220-470 Ohmios. Con valores menores se corre el riesgo de da\u00f1arlo y valores mayores aten\u00faan demasiado el brillo. Seguidamente unimos mediante cables el pin 10 con la fila del \u00e1nodo (pata larga) y el GND con la fila del extremo libre de la resistencia. Si el led tiene las patas iguales, una forma de distinguir el c\u00e1todo del \u00e1nodo es fij\u00e1ndose en el borde del led que no es completamente circular. Pues la parte biselada corresponde al c\u00e1todo. Ahora vamos con el programa. En la primera parte declaramos las variables. int pinsalida = 10; // variable para guardar el n\u00famero del pin int velocidad = 100; // variable para cambiar la velocidad de encendido/apagado int pwm; // variable que almacenar\u00e1 el valor entre 0 y 255 Cambiando el valor de la variable velocidad haremos que el led tarde m\u00e1s o menos tiempo en completar los ciclos de cambio de intensidad. En la funci\u00f3n setup hacemos que el led se encienda 2 segundos y luego se apague. void setup() { pinMode(pinsalida,OUTPUT); // configura \"pinsalida\" como salida digitalWrite(pinsalida,HIGH); // pone el \"pinsalida\" a nivel alto delay(2000); // espera 2000 milisegundos (2 segundos) pinMode(pinsalida,LOW); // pon \"pinsalida a nivel bajo delay(1000); // espera 1 segundo } En la funci\u00f3n loop hacemos uso del PWM. Escribimos un bucle for que dar\u00e1 a la variable pwm un valor inicial de 0 y lo ir\u00e1 incrementando en una unidad hasta que alcance el valor m\u00e1ximo de 255. A continuaci\u00f3n ponemos otro bucle for que ir\u00e1 decrementando el valor desde el m\u00e1ximo hasta el m\u00ednimo. void loop() { for(pwm=0;pwm<256;pwm++) // desde pwm valiendo 0; hasta que valga 255; incrementa pwm { analogWrite(pinsalida,pwm); // pone el \"pinsalida\" a el valor que almacena la variable \"pwm\" delay(1000/velocidad); // espera (1000/velocidad) milisegundos } for(pwm=255;pwm>-1;pwm--) // este bucle hace lo mismo pero decrementando pwm { analogWrite(pinsalida,pwm); delay(1000/velocidad); } } El programa entero quedar\u00eda as\u00ed. /***********************/ /* ejemplo led pwm */ /***********************/ int pinsalida = 10; // variable para guardar el n\u00famero del pin int velocidad = 100; // variable para cambiar la velocidad de encendido/apagado int pwm; // variable que almacenar\u00e1 el valor entre 0 y 255 void setup() { pinMode(pinsalida,OUTPUT); // configura \"pinsalida\" como salida digitalWrite(pinsalida,HIGH); // pone el \"pinsalida\" a nivel alto delay(2000); // espera 2000 milisegundos (2 segundos) pinMode(pinsalida,LOW); // pon \"pinsalida a nivel bajo delay(1000); // espera 1 segundo } void loop() { for(pwm=0;pwm<256;pwm++) // desde pwm valiendo 0; hasta que valga 255; incrementa pwm { analogWrite(pinsalida,pwm); // pone el \"pinsalida\" a el valor que almacena la variable \"pwm\" delay(1000/velocidad); // espera (1000/velocidad) milisegundos } for(pwm=255;pwm>-1;pwm--) // este bucle hace lo mismo pero decrementando pwm { analogWrite(pinsalida,pwm); delay(1000/velocidad); } }","title":"Ejemplo funci\u00f3n PWM con LED"},{"location":"05_entradas_analogicas_y_digitales/","text":"Tras realizar este tutorial, puedes profundizar en este tema con el curso de Arduino , perfecto para aprender de forma pr\u00e1ctica a programar en Arduino desde cero. En este momento puedes acceder a este curso y muchos m\u00e1s de forma gratuita gracias al periodo de prueba de 15 d\u00edas que ofrecemos en estos momentos. Descripci\u00f3n de las entradas Nuestro Arduino no s\u00f3lo puede enviar se\u00f1ales sino que tambi\u00e9n puede recibirlas con dos prop\u00f3sitos principales como son leer datos de sensores y recibir mensajes de otros dispositivos (shield, otro Arduino, PC, etc.). Las entradas las clasificaremos en anal\u00f3gicas y digitales. Entradas anal\u00f3gicas Las entradas anal\u00f3gicas del modelo Uno son las correspondientes a los pines de A0 a A5. Se caracterizan por leer valores de tensi\u00f3n de 0 a 5 Voltios con una resoluci\u00f3n de 1024 (10 bits). Si dividimos 5 entre 1024 tenemos que ser capaz de detectar variaciones en el nivel de la se\u00f1al de entrada de casi 5 mV. Para hacer la lectura de uno de estos pines escribiremos en nuestro c\u00f3digo lectura = analogRead(pinentrada); \u201clectura\u201d lo sustituimos por el nombre de la variable donde queramos almacenar el valor le\u00eddo y en \u201cpinentrada\u201d tendremos que poner el n\u00famero del pin anal\u00f3gico que hemos elegido (0,1,...5) o el nombre de la variable que almacena dicho n\u00famero. Esta funci\u00f3n nos devolver\u00e1 un valor que va de 0 a 1023 en proporci\u00f3n al nivel de la se\u00f1al de entrada. Para una entrada nula obtendremos el valor 0, para una entrada de 2.5 Voltios 511 (la mitad de 1023) y para 5 Voltios 1023. Entradas digitales Las entradas digitales son las mismas que las salidas digitales, es decir, los pines que van del 1 al 13. Se diferencian de las anal\u00f3gicas porque \u00e9stas son capaces de \u201centender\u201d s\u00f3lo dos niveles de se\u00f1al, LOW o valores cercanos a 0 V y HIGH o valores cercanos a 5 V. Puede parecer una desventaja pero en realidad puede ser todo lo contrario. Y no s\u00f3lo porque a veces \u00fanicamente necesitemos saber dos estados (interruptor, pulsador, sensor de presencia, final de carrera....) sino porque as\u00ed es capaz de leer se\u00f1ales de pulsos digitales. Esto significa que puede comunicarse . Por poner un ejemplo, un sensor anal\u00f3gico de temperatura como es el LM35 incrementar\u00eda el nivel de la tensi\u00f3n que llega a la placa de forma proporcional a la temperatura. Sin embargo, uno digital como el ds18b20 lo que har\u00eda es cambiar la sucesi\u00f3n de pulsos y por tanto el mensaje que contiene el valor de la temperatura. Aunque los pines digitales por defecto vienen configurados como entradas, si queremos hacerlo manualmente escribimos en nuestro c\u00f3digo pinMode(pinentrada,INPUT); Para almacenar los dos valores posibles LOW o HIGH en una variable llamada \u201clectura\u201d escribimos lectura = digitalRead(pinentrada); Medici\u00f3n de temperatura. Sensor M35 Este sensor de temperatura lo pod\u00e9is encontrar por poco m\u00e1s de 1\u20ac . Es un sensor lineal, tiene una precisi\u00f3n de 0.5 \u00baC y una sensibilidad de 10 mV/\u00baC. Pod\u00e9is encontrar m\u00e1s informaci\u00f3n en su datasheet . Vamos a hacer un peque\u00f1o proyecto para medir la temperatura ambiente y visualizarla en nuestro PC. Su montaje no lleva m\u00e1s de un par de minutos y podemos verlo claramente en el esquema. La pata +Vs va al pin 5V, la pata Vout al pin que utilicemos para la lectura, en este caso el 0, y la restante GND al pin GND. Tened en cuenta que el dibujo del LM35 est\u00e1 hecho con vista desde las patas . CUIDADO con colocarlo al rev\u00e9s porque si lo hac\u00e9is mal el sensor se calentar\u00e1 r\u00e1pidamente y a parte de estropearlo os quemar\u00e9is al tocarlo. El programa para este ejemplo es tambi\u00e9n muy simple y corto. Como siempre empezamos con la declaraci\u00f3n de las variables. Esta vez, para almacenar la temperatura no utilizaremos una variable del tipo int sino float para poder almacenar decimales. float temperatura; // aqu\u00ed almacenaremos el valor le\u00eddo int pinentrada = 0; // utilizaremos el pin A Lo siguiente es abrir el puerto serial en la funci\u00f3n setup . \u00c9sto se hace para poder comunicarnos desde nuestro ordenador con el controlador y as\u00ed poder mostrar los datos por pantalla. void setup() { Serial.begin(9600); // abrimos el puerto reial a 9600 bps } En el c\u00f3digo quedar\u00eda as\u00ed void loop() { temperatura = analogRead(pinentrada); // lectura del pin A0 temperatura = (temperatura / 1023 * 5 / 0.01); // \"traduce\" el valor le\u00eddo a grados Serial.print(temperatura); // escribe el valor de la temperatura por el puerto serial Serial.print(\" grados centigrados \\n\"); // escribe las unidades delay(1000); // espera 1 segundo } Cargamos el c\u00f3digo en la placa y s\u00f3lo tenemos que pinchar en el icono del monitor serial Si nos muestras caracteres extra\u00f1os es que la configuraci\u00f3n del monitor serial est\u00e1 comunic\u00e1ndose con una tasa bps distinta a los 9600 con los que hemos configurado nuestro puerto serial. Para corregirlo s\u00f3lo tenemos que seleccionar el valor adecuado de la pesta\u00f1a desplegable como se puede ver en la siguiente imagen. Os dejo el programa entero para que s\u00f3lo teng\u00e1is que copiar y pegar a vuestro IDE. /*****************************/ /* Medicion de Temperatura */ /* con el sensor LM35 */ /*****************************/ /****** declaracion de variables ******/ float temperatura; // almacenara el valor leido int pinentrada = 0; // utilizaremos el pin A0 void setup() { Serial.begin(9600); // abrimos el puerto serial a 9600 bps } void loop() { temperatura = analogRead(pinentrada); // lectura del pin A0 temperatura = (temperatura / 1023 * 5 / 0.01); // traduce el valor a \u00baC Serial.print(temperatura); // escribe el valor por el puerto serial Serial.print(\" grados centigrados \\n\"); // escribe las unidades de \u00baC delay(1000); // espera un segundo }","title":"05 entradas analogicas y digitales"},{"location":"05_entradas_analogicas_y_digitales/#descripcion-de-las-entradas","text":"Nuestro Arduino no s\u00f3lo puede enviar se\u00f1ales sino que tambi\u00e9n puede recibirlas con dos prop\u00f3sitos principales como son leer datos de sensores y recibir mensajes de otros dispositivos (shield, otro Arduino, PC, etc.). Las entradas las clasificaremos en anal\u00f3gicas y digitales.","title":"Descripci\u00f3n de las entradas"},{"location":"05_entradas_analogicas_y_digitales/#entradas-analogicas","text":"Las entradas anal\u00f3gicas del modelo Uno son las correspondientes a los pines de A0 a A5. Se caracterizan por leer valores de tensi\u00f3n de 0 a 5 Voltios con una resoluci\u00f3n de 1024 (10 bits). Si dividimos 5 entre 1024 tenemos que ser capaz de detectar variaciones en el nivel de la se\u00f1al de entrada de casi 5 mV. Para hacer la lectura de uno de estos pines escribiremos en nuestro c\u00f3digo lectura = analogRead(pinentrada); \u201clectura\u201d lo sustituimos por el nombre de la variable donde queramos almacenar el valor le\u00eddo y en \u201cpinentrada\u201d tendremos que poner el n\u00famero del pin anal\u00f3gico que hemos elegido (0,1,...5) o el nombre de la variable que almacena dicho n\u00famero. Esta funci\u00f3n nos devolver\u00e1 un valor que va de 0 a 1023 en proporci\u00f3n al nivel de la se\u00f1al de entrada. Para una entrada nula obtendremos el valor 0, para una entrada de 2.5 Voltios 511 (la mitad de 1023) y para 5 Voltios 1023.","title":"Entradas anal\u00f3gicas"},{"location":"05_entradas_analogicas_y_digitales/#entradas-digitales","text":"Las entradas digitales son las mismas que las salidas digitales, es decir, los pines que van del 1 al 13. Se diferencian de las anal\u00f3gicas porque \u00e9stas son capaces de \u201centender\u201d s\u00f3lo dos niveles de se\u00f1al, LOW o valores cercanos a 0 V y HIGH o valores cercanos a 5 V. Puede parecer una desventaja pero en realidad puede ser todo lo contrario. Y no s\u00f3lo porque a veces \u00fanicamente necesitemos saber dos estados (interruptor, pulsador, sensor de presencia, final de carrera....) sino porque as\u00ed es capaz de leer se\u00f1ales de pulsos digitales. Esto significa que puede comunicarse . Por poner un ejemplo, un sensor anal\u00f3gico de temperatura como es el LM35 incrementar\u00eda el nivel de la tensi\u00f3n que llega a la placa de forma proporcional a la temperatura. Sin embargo, uno digital como el ds18b20 lo que har\u00eda es cambiar la sucesi\u00f3n de pulsos y por tanto el mensaje que contiene el valor de la temperatura. Aunque los pines digitales por defecto vienen configurados como entradas, si queremos hacerlo manualmente escribimos en nuestro c\u00f3digo pinMode(pinentrada,INPUT); Para almacenar los dos valores posibles LOW o HIGH en una variable llamada \u201clectura\u201d escribimos lectura = digitalRead(pinentrada);","title":"Entradas digitales"},{"location":"05_entradas_analogicas_y_digitales/#medicion-de-temperatura-sensor-m35","text":"Este sensor de temperatura lo pod\u00e9is encontrar por poco m\u00e1s de 1\u20ac . Es un sensor lineal, tiene una precisi\u00f3n de 0.5 \u00baC y una sensibilidad de 10 mV/\u00baC. Pod\u00e9is encontrar m\u00e1s informaci\u00f3n en su datasheet . Vamos a hacer un peque\u00f1o proyecto para medir la temperatura ambiente y visualizarla en nuestro PC. Su montaje no lleva m\u00e1s de un par de minutos y podemos verlo claramente en el esquema. La pata +Vs va al pin 5V, la pata Vout al pin que utilicemos para la lectura, en este caso el 0, y la restante GND al pin GND. Tened en cuenta que el dibujo del LM35 est\u00e1 hecho con vista desde las patas . CUIDADO con colocarlo al rev\u00e9s porque si lo hac\u00e9is mal el sensor se calentar\u00e1 r\u00e1pidamente y a parte de estropearlo os quemar\u00e9is al tocarlo. El programa para este ejemplo es tambi\u00e9n muy simple y corto. Como siempre empezamos con la declaraci\u00f3n de las variables. Esta vez, para almacenar la temperatura no utilizaremos una variable del tipo int sino float para poder almacenar decimales. float temperatura; // aqu\u00ed almacenaremos el valor le\u00eddo int pinentrada = 0; // utilizaremos el pin A Lo siguiente es abrir el puerto serial en la funci\u00f3n setup . \u00c9sto se hace para poder comunicarnos desde nuestro ordenador con el controlador y as\u00ed poder mostrar los datos por pantalla. void setup() { Serial.begin(9600); // abrimos el puerto reial a 9600 bps } En el c\u00f3digo quedar\u00eda as\u00ed void loop() { temperatura = analogRead(pinentrada); // lectura del pin A0 temperatura = (temperatura / 1023 * 5 / 0.01); // \"traduce\" el valor le\u00eddo a grados Serial.print(temperatura); // escribe el valor de la temperatura por el puerto serial Serial.print(\" grados centigrados \\n\"); // escribe las unidades delay(1000); // espera 1 segundo } Cargamos el c\u00f3digo en la placa y s\u00f3lo tenemos que pinchar en el icono del monitor serial Si nos muestras caracteres extra\u00f1os es que la configuraci\u00f3n del monitor serial est\u00e1 comunic\u00e1ndose con una tasa bps distinta a los 9600 con los que hemos configurado nuestro puerto serial. Para corregirlo s\u00f3lo tenemos que seleccionar el valor adecuado de la pesta\u00f1a desplegable como se puede ver en la siguiente imagen. Os dejo el programa entero para que s\u00f3lo teng\u00e1is que copiar y pegar a vuestro IDE. /*****************************/ /* Medicion de Temperatura */ /* con el sensor LM35 */ /*****************************/ /****** declaracion de variables ******/ float temperatura; // almacenara el valor leido int pinentrada = 0; // utilizaremos el pin A0 void setup() { Serial.begin(9600); // abrimos el puerto serial a 9600 bps } void loop() { temperatura = analogRead(pinentrada); // lectura del pin A0 temperatura = (temperatura / 1023 * 5 / 0.01); // traduce el valor a \u00baC Serial.print(temperatura); // escribe el valor por el puerto serial Serial.print(\" grados centigrados \\n\"); // escribe las unidades de \u00baC delay(1000); // espera un segundo }","title":"Medici\u00f3n de temperatura. Sensor M35"},{"location":"06_entradas_botones/","text":"Botones En este post, haremos una extensi\u00f3n del anterior. Nos detendremos en uno de los elementos m\u00e1s b\u00e1sicos en el control de Arduino, pero de los m\u00e1s usados y pr\u00e1cticos, los botones . \u00c9stos son un tipo de elemento externo que nos permite controlar f\u00edsicamente acciones a realizar por nuestro sistema a trav\u00e9s de dar continuidad o no a la se\u00f1al de entrada en la que est\u00e1n instalados. Como podr\u00e9is imaginar son parte fundamental de casi cualquier proyecto y son muy f\u00e1ciles de usar y programar, aunque hay que tener en cuenta un par de detalles a la hora de usarlos. Para comprender bien c\u00f3mo funcionan en los distintos casos y c\u00f3mo solucionar algunos problemillas propios de los botones, realizaremos 3 ejemplos para verlos detalladamente y en los que usaremos el mismo circuito/esquema y solo iremos variando su programaci\u00f3n. Esquema com\u00fan Para realizar todos los ejemplos necesitaremos los siguientes elementos: \u2022 1 x Arduino UNO R3 \u2022 1 X Protoboard \u2022 1 x led (usaremos rojo pero vale cualquier color) \u2022 1 x Bot\u00f3n \u2022 1x Resistencia de 220\u2126 (puede valer de 330\u2126) \u2022 1 x Resistencia de 10k\u2126 (puede valer de 1 \u00f3 5 k\u2126) \u2022 Cables para conectar todo Con todo comenzaremos a montar nuestro circuito como se describe en el siguiente esquema. Ilustraci\u00f3n 1 Esquema de montaje del interruptor. Usaremos el pin 2 para encender el led y el 4 para saber el estado del bot\u00f3n. Al montarlo debemos tener en cuenta un par de detalles. Primero, que conectemos correctamente la polaridad del led, siguiendo las indicaciones que os dimos en el ejemplo del sem\u00e1foro. Segundo, que usemos la resistencia de 10k\u2126 para conectar el bot\u00f3n a tierra . Esto es muy importante, ya que con eso protegemos a nuestra placa de crear un cortocircuito a tierra que podr\u00eda deteriorarla. La resistencia de 220\u2126, como en ejemplos anteriores, la usaremos para conectar el led a tierra. Ilustraci\u00f3n 2 Montaje real para ejemplos de botones e interruptores Pulsador Empezaremos con el bot\u00f3n m\u00e1s sencillo de programar y usar que tenemos, el pulsador . \u00c9ste nos permite realizar una acci\u00f3n mientras mantengamos pulsado nuestro bot\u00f3n, por ejemplo que un led se quede encendido mientras estemos pulsando. Para nuestro programa declararemos una variable llamada \u201c pulsador \u201d que usaremos para saber si nuestro bot\u00f3n est\u00e1 pulsado o no. int pulsador=0; Dentro del setup, configuraremos el pin digital 2 como salida para poder dar la orden de encender o apagar. pinMode(2, OUTPUT); Para que podamos saber en qu\u00e9 estado se encuentra nuestro bot\u00f3n configuraremos el pin digital 4 como entrada . pinMode(4, INPUT); Finalmente nuestro c\u00f3digo loop lo que har\u00e1 ser\u00e1, primero leer del pin 4 en qu\u00e9 estado est\u00e1 el bot\u00f3n mediante la sentencia digitalRead. Este valor lo almacenaremos en la variable \u201cpulsador\u201d que declaramos anteriormente. pulsador = digitalRead(4); Una vez que sepa c\u00f3mo se encuentra el bot\u00f3n, mediante una funci\u00f3n \u201cif\u201d, si el pulsador est\u00e1 HIGH (pulsado) encender\u00e1 el led y si el pulsador est\u00e1 en LOW (sin pulsar) lo apagar\u00e1. if(pulsador==HIGH) { digitalWrite(2, HIGH); } else{ digitalWrite(2, LOW); El c\u00f3digo completo quedar\u00eda as\u00ed: /**************************/ /* Encender LED con Bot\u00f3n */ /* Pulsador */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee el estado del bot\u00f3n if(pulsador==HIGH) { //si el estado es pulsado digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es no pulsado digitalWrite(2, LOW); //se apaga el led } } Interruptor Con este tipo, podremos usar un bot\u00f3n de la misma manera que si us\u00e1ramos un interruptor de los que conocemos com\u00fanmente. Cuando pulsemos, se realizar\u00e1 la acci\u00f3n programada (encender el led) y se mantendr\u00e1 en este estado hasta que volvamos a pulsar nuevamente (se apagar\u00e1 el led). Para obtener este tipo de bot\u00f3n solo haremos una peque\u00f1a modificaci\u00f3n del c\u00f3digo anterior. Introduciremos una nueva variable llamada \u201c estado \u201d que almacene el estado en el que se dej\u00f3 el led tras la \u00faltima pulsaci\u00f3n. De esta forma cuando pulsemos, Arduino se acordar\u00e1 si el led estaba encendido o apagado. int estado=0; Usaremos esta \u201cmemoria\u201d de Arduino para alternar entre encendido y apagado cada vez que pulsemos. Esto lo haremos modificando el c\u00f3digo en la zona de void loop(). Primero introducimos un \u201cif\u201d que har\u00e1 que cuando pulsemos el bot\u00f3n alterne el valor de la variable estado entre 0 y 1. if(pulsador==HIGH){ estado=1-estado; } La expresi\u00f3n \u201cestado=1-estado\u201d lo que hace es que si el estado era apagado, igual a 0, al pulsar almacenar\u00e1 en la variable el valor 1-0 =1 y si el estado era encendido, igual a 1, al pulsar almacenar\u00e1 1-1=0. Despu\u00e9s, en vez de comprobar c\u00f3mo est\u00e1 la variable \u201cpulsador\u201d, como hac\u00edamos antes, lo que comprobamos es el valor que tiene la variable \u201cestado\u201d. Si es 1 encender\u00e1 el led y si es 0 lo apagar\u00e1. if(estado==1) { digitalWrite(2, HIGH); } else{ digitalWrite(2, LOW); Os dejamos el c\u00f3digo completo para que solo teng\u00e1is que copiar y pegar en el IDE. /**************************/ /* Encender LED con Bot\u00f3n */ /* Interruptor 1 */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n int estado=0; //0=led apagado, 1=led encendido //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee si el bot\u00f3n est\u00e1 pulsado if(pulsador==HIGH){ //si el boton es pulsado estado=1-estado; } if(estado==1) { //si el estado es 1 digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es 0 digitalWrite(2, LOW); //se apaga el led } } Interruptor con correcci\u00f3n de rebote Al realizar el anterior ejemplo de interruptor, podr\u00e9is daros cuenta que hay algunas veces que nuestro bot\u00f3n falla y no hace correctamente su funci\u00f3n. Es imposible predecir su comportamiento. A este efecto se le denomina rebote y es debido a varios motivos. Aqu\u00ed vamos a dar un par de soluciones r\u00e1pidas y efectivas que nos pueden ayudar en la mayor\u00eda de casos, pero en el m\u00f3dulo de nivel intermedio explicaremos una soluci\u00f3n al problema del \u201c debounce \u201d m\u00e1s elaborada y fiable. Uno de los motivos de este efecto, es que Arduino repite nuestro loop de instrucciones miles de veces cada segundo. Esto provoca que cuando pulsamos el bot\u00f3n una sola vez, Arduino leer\u00e1 cientos de veces seguidas que hemos pulsado e interpretar\u00e1 que hemos pulsado todas esas veces. Por eso, la acci\u00f3n de encender y apagar se repetir\u00e1 muy r\u00e1pidamente, sin que lo apreciemos, hasta dejar el led en la \u00faltima posici\u00f3n le\u00edda. Solucionar esto es sencillo. Solo tenemos que introducir una nueva variable \u201c pulsadorAnt \u201d donde almacenemos en qu\u00e9 estado anterior se encontraba el bot\u00f3n, pulsado o no, antes de nuestra pulsaci\u00f3n. int pulsadorAnt=0; Seguidamente, en nuestro loop, modificaremos el primer \u201cif\u201d que ten\u00edamos introduciendo una segunda condici\u00f3n. Diremos que para que Arduino cambie la posici\u00f3n del interruptor, no solo debe leer que el bot\u00f3n est\u00e1 pulsado, \u201cpulsador==HIGH\u201d, sino que tambi\u00e9n debe cumplirse que justo en el instante antes no estuviese pulsado, \u201cpulsadorAnt==LOW\u201d. De esta forma Arduino solo leer\u00e1 nuestra pulsaci\u00f3n una sola vez cada vez que pulsemos. if((pulsador==HIGH)&&(pulsadorAnt==LOW)){ estado=1-estado; } Para finalizar, justo despu\u00e9s de este \u201cif\u201d, actualizaremos el valor de la variable \u201cpulsadorAnt\u201d con el nuevo valor de \u201cpulsador\u201d mediante la siguiente l\u00ednea. pulsadorAnt=pulsador; Si carg\u00e1semos ya este nuevo c\u00f3digo a la placa, ver\u00edamos que nuestro problema se ha solucionado casi del todo, pero que a\u00fan, algunas veces, falla su funcionamiento. Esto es debido a la propia construcci\u00f3n del bot\u00f3n. Un bot\u00f3n, internamente, no es m\u00e1s que dos l\u00e1minas met\u00e1licas que se unen o separan por la acci\u00f3n de un resorte. En el momento de la uni\u00f3n, o separaci\u00f3n, de las l\u00e1minas, el resorte provoca una serie de rebotes entre las l\u00e1minas que Arduino es capaz de detectar. Ilustraci\u00f3n 3 Gr\u00e1fico del efecto rebote en el apagado y encendido de un bot\u00f3n. Para evitar este problema, una soluci\u00f3n sencilla es meter una peque\u00f1\u00edsima pausa al programa justo despu\u00e9s de que Arduino detecte nuestra pulsaci\u00f3n. De esta forma, cuando el c\u00f3digo retome su funcionamiento, los rebotes habr\u00e1n terminado y no ser\u00e1n detectados. En nuestro caso introduciremos una pausa de 40 milisegundos, aunque pod\u00e9is probar a variar este valor a vuestro gusto para afinar el resultado. delay(40); Podr\u00e9is observar que a\u00fan falla alguna vez pero que su funcionamiento es bastante m\u00e1s preciso que antes. Esto es todo. Esperamos que se haya entendido bien y que no quede muy lioso. Al seguir los pasos ver\u00e9is que es muy f\u00e1cil y divertido. Os dejamos el c\u00f3digo completo. /**************************/ /* Encender LED con Bot\u00f3n */ /* Interruptor sin rebote */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n int estado=0; //0=led apagado, 1=led encendido int pulsadorAnt=0; //almacena el estado anterior del boton //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee si el bot\u00f3n est\u00e1 pulsado if((pulsador==HIGH)&&(pulsadorAnt==LOW)){ //si el boton es pulsado y antes no lo estaba estado=1-estado; delay(40); //pausa de 40 ms } pulsadorAnt=pulsador; //actualiza el nuevo estado del boton if(estado==1) { //si el estado es 1 digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es 0 digitalWrite(2, LOW); //se apaga el led } }","title":"06 entradas botones"},{"location":"06_entradas_botones/#botones","text":"En este post, haremos una extensi\u00f3n del anterior. Nos detendremos en uno de los elementos m\u00e1s b\u00e1sicos en el control de Arduino, pero de los m\u00e1s usados y pr\u00e1cticos, los botones . \u00c9stos son un tipo de elemento externo que nos permite controlar f\u00edsicamente acciones a realizar por nuestro sistema a trav\u00e9s de dar continuidad o no a la se\u00f1al de entrada en la que est\u00e1n instalados. Como podr\u00e9is imaginar son parte fundamental de casi cualquier proyecto y son muy f\u00e1ciles de usar y programar, aunque hay que tener en cuenta un par de detalles a la hora de usarlos. Para comprender bien c\u00f3mo funcionan en los distintos casos y c\u00f3mo solucionar algunos problemillas propios de los botones, realizaremos 3 ejemplos para verlos detalladamente y en los que usaremos el mismo circuito/esquema y solo iremos variando su programaci\u00f3n. Esquema com\u00fan Para realizar todos los ejemplos necesitaremos los siguientes elementos: \u2022 1 x Arduino UNO R3 \u2022 1 X Protoboard \u2022 1 x led (usaremos rojo pero vale cualquier color) \u2022 1 x Bot\u00f3n \u2022 1x Resistencia de 220\u2126 (puede valer de 330\u2126) \u2022 1 x Resistencia de 10k\u2126 (puede valer de 1 \u00f3 5 k\u2126) \u2022 Cables para conectar todo Con todo comenzaremos a montar nuestro circuito como se describe en el siguiente esquema. Ilustraci\u00f3n 1 Esquema de montaje del interruptor. Usaremos el pin 2 para encender el led y el 4 para saber el estado del bot\u00f3n. Al montarlo debemos tener en cuenta un par de detalles. Primero, que conectemos correctamente la polaridad del led, siguiendo las indicaciones que os dimos en el ejemplo del sem\u00e1foro. Segundo, que usemos la resistencia de 10k\u2126 para conectar el bot\u00f3n a tierra . Esto es muy importante, ya que con eso protegemos a nuestra placa de crear un cortocircuito a tierra que podr\u00eda deteriorarla. La resistencia de 220\u2126, como en ejemplos anteriores, la usaremos para conectar el led a tierra. Ilustraci\u00f3n 2 Montaje real para ejemplos de botones e interruptores","title":"Botones"},{"location":"06_entradas_botones/#pulsador","text":"Empezaremos con el bot\u00f3n m\u00e1s sencillo de programar y usar que tenemos, el pulsador . \u00c9ste nos permite realizar una acci\u00f3n mientras mantengamos pulsado nuestro bot\u00f3n, por ejemplo que un led se quede encendido mientras estemos pulsando. Para nuestro programa declararemos una variable llamada \u201c pulsador \u201d que usaremos para saber si nuestro bot\u00f3n est\u00e1 pulsado o no. int pulsador=0; Dentro del setup, configuraremos el pin digital 2 como salida para poder dar la orden de encender o apagar. pinMode(2, OUTPUT); Para que podamos saber en qu\u00e9 estado se encuentra nuestro bot\u00f3n configuraremos el pin digital 4 como entrada . pinMode(4, INPUT); Finalmente nuestro c\u00f3digo loop lo que har\u00e1 ser\u00e1, primero leer del pin 4 en qu\u00e9 estado est\u00e1 el bot\u00f3n mediante la sentencia digitalRead. Este valor lo almacenaremos en la variable \u201cpulsador\u201d que declaramos anteriormente. pulsador = digitalRead(4); Una vez que sepa c\u00f3mo se encuentra el bot\u00f3n, mediante una funci\u00f3n \u201cif\u201d, si el pulsador est\u00e1 HIGH (pulsado) encender\u00e1 el led y si el pulsador est\u00e1 en LOW (sin pulsar) lo apagar\u00e1. if(pulsador==HIGH) { digitalWrite(2, HIGH); } else{ digitalWrite(2, LOW); El c\u00f3digo completo quedar\u00eda as\u00ed: /**************************/ /* Encender LED con Bot\u00f3n */ /* Pulsador */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee el estado del bot\u00f3n if(pulsador==HIGH) { //si el estado es pulsado digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es no pulsado digitalWrite(2, LOW); //se apaga el led } }","title":"Pulsador"},{"location":"06_entradas_botones/#interruptor","text":"Con este tipo, podremos usar un bot\u00f3n de la misma manera que si us\u00e1ramos un interruptor de los que conocemos com\u00fanmente. Cuando pulsemos, se realizar\u00e1 la acci\u00f3n programada (encender el led) y se mantendr\u00e1 en este estado hasta que volvamos a pulsar nuevamente (se apagar\u00e1 el led). Para obtener este tipo de bot\u00f3n solo haremos una peque\u00f1a modificaci\u00f3n del c\u00f3digo anterior. Introduciremos una nueva variable llamada \u201c estado \u201d que almacene el estado en el que se dej\u00f3 el led tras la \u00faltima pulsaci\u00f3n. De esta forma cuando pulsemos, Arduino se acordar\u00e1 si el led estaba encendido o apagado. int estado=0; Usaremos esta \u201cmemoria\u201d de Arduino para alternar entre encendido y apagado cada vez que pulsemos. Esto lo haremos modificando el c\u00f3digo en la zona de void loop(). Primero introducimos un \u201cif\u201d que har\u00e1 que cuando pulsemos el bot\u00f3n alterne el valor de la variable estado entre 0 y 1. if(pulsador==HIGH){ estado=1-estado; } La expresi\u00f3n \u201cestado=1-estado\u201d lo que hace es que si el estado era apagado, igual a 0, al pulsar almacenar\u00e1 en la variable el valor 1-0 =1 y si el estado era encendido, igual a 1, al pulsar almacenar\u00e1 1-1=0. Despu\u00e9s, en vez de comprobar c\u00f3mo est\u00e1 la variable \u201cpulsador\u201d, como hac\u00edamos antes, lo que comprobamos es el valor que tiene la variable \u201cestado\u201d. Si es 1 encender\u00e1 el led y si es 0 lo apagar\u00e1. if(estado==1) { digitalWrite(2, HIGH); } else{ digitalWrite(2, LOW); Os dejamos el c\u00f3digo completo para que solo teng\u00e1is que copiar y pegar en el IDE. /**************************/ /* Encender LED con Bot\u00f3n */ /* Interruptor 1 */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n int estado=0; //0=led apagado, 1=led encendido //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee si el bot\u00f3n est\u00e1 pulsado if(pulsador==HIGH){ //si el boton es pulsado estado=1-estado; } if(estado==1) { //si el estado es 1 digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es 0 digitalWrite(2, LOW); //se apaga el led } }","title":"Interruptor"},{"location":"06_entradas_botones/#interruptor-con-correccion-de-rebote","text":"Al realizar el anterior ejemplo de interruptor, podr\u00e9is daros cuenta que hay algunas veces que nuestro bot\u00f3n falla y no hace correctamente su funci\u00f3n. Es imposible predecir su comportamiento. A este efecto se le denomina rebote y es debido a varios motivos. Aqu\u00ed vamos a dar un par de soluciones r\u00e1pidas y efectivas que nos pueden ayudar en la mayor\u00eda de casos, pero en el m\u00f3dulo de nivel intermedio explicaremos una soluci\u00f3n al problema del \u201c debounce \u201d m\u00e1s elaborada y fiable. Uno de los motivos de este efecto, es que Arduino repite nuestro loop de instrucciones miles de veces cada segundo. Esto provoca que cuando pulsamos el bot\u00f3n una sola vez, Arduino leer\u00e1 cientos de veces seguidas que hemos pulsado e interpretar\u00e1 que hemos pulsado todas esas veces. Por eso, la acci\u00f3n de encender y apagar se repetir\u00e1 muy r\u00e1pidamente, sin que lo apreciemos, hasta dejar el led en la \u00faltima posici\u00f3n le\u00edda. Solucionar esto es sencillo. Solo tenemos que introducir una nueva variable \u201c pulsadorAnt \u201d donde almacenemos en qu\u00e9 estado anterior se encontraba el bot\u00f3n, pulsado o no, antes de nuestra pulsaci\u00f3n. int pulsadorAnt=0; Seguidamente, en nuestro loop, modificaremos el primer \u201cif\u201d que ten\u00edamos introduciendo una segunda condici\u00f3n. Diremos que para que Arduino cambie la posici\u00f3n del interruptor, no solo debe leer que el bot\u00f3n est\u00e1 pulsado, \u201cpulsador==HIGH\u201d, sino que tambi\u00e9n debe cumplirse que justo en el instante antes no estuviese pulsado, \u201cpulsadorAnt==LOW\u201d. De esta forma Arduino solo leer\u00e1 nuestra pulsaci\u00f3n una sola vez cada vez que pulsemos. if((pulsador==HIGH)&&(pulsadorAnt==LOW)){ estado=1-estado; } Para finalizar, justo despu\u00e9s de este \u201cif\u201d, actualizaremos el valor de la variable \u201cpulsadorAnt\u201d con el nuevo valor de \u201cpulsador\u201d mediante la siguiente l\u00ednea. pulsadorAnt=pulsador; Si carg\u00e1semos ya este nuevo c\u00f3digo a la placa, ver\u00edamos que nuestro problema se ha solucionado casi del todo, pero que a\u00fan, algunas veces, falla su funcionamiento. Esto es debido a la propia construcci\u00f3n del bot\u00f3n. Un bot\u00f3n, internamente, no es m\u00e1s que dos l\u00e1minas met\u00e1licas que se unen o separan por la acci\u00f3n de un resorte. En el momento de la uni\u00f3n, o separaci\u00f3n, de las l\u00e1minas, el resorte provoca una serie de rebotes entre las l\u00e1minas que Arduino es capaz de detectar. Ilustraci\u00f3n 3 Gr\u00e1fico del efecto rebote en el apagado y encendido de un bot\u00f3n. Para evitar este problema, una soluci\u00f3n sencilla es meter una peque\u00f1\u00edsima pausa al programa justo despu\u00e9s de que Arduino detecte nuestra pulsaci\u00f3n. De esta forma, cuando el c\u00f3digo retome su funcionamiento, los rebotes habr\u00e1n terminado y no ser\u00e1n detectados. En nuestro caso introduciremos una pausa de 40 milisegundos, aunque pod\u00e9is probar a variar este valor a vuestro gusto para afinar el resultado. delay(40); Podr\u00e9is observar que a\u00fan falla alguna vez pero que su funcionamiento es bastante m\u00e1s preciso que antes. Esto es todo. Esperamos que se haya entendido bien y que no quede muy lioso. Al seguir los pasos ver\u00e9is que es muy f\u00e1cil y divertido. Os dejamos el c\u00f3digo completo. /**************************/ /* Encender LED con Bot\u00f3n */ /* Interruptor sin rebote */ /**************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int pulsador=0; //almacena el estado del bot\u00f3n int estado=0; //0=led apagado, 1=led encendido int pulsadorAnt=0; //almacena el estado anterior del boton //** Programa **// void setup() { pinMode(2, OUTPUT); //declaramos el pin 2 como salida pinMode(4, INPUT); //declaramos el pin 4 como entrada } void loop() { pulsador = digitalRead(4); //lee si el bot\u00f3n est\u00e1 pulsado if((pulsador==HIGH)&&(pulsadorAnt==LOW)){ //si el boton es pulsado y antes no lo estaba estado=1-estado; delay(40); //pausa de 40 ms } pulsadorAnt=pulsador; //actualiza el nuevo estado del boton if(estado==1) { //si el estado es 1 digitalWrite(2, HIGH); //se enciende el led } else{ //si el estado es 0 digitalWrite(2, LOW); //se apaga el led } }","title":"Interruptor con correcci\u00f3n de rebote"},{"location":"07_comunicacion_serie/","text":"1.- \u00bfQu\u00e9 es la comunicaci\u00f3n serie? Antes de comenzar, aclararemos que no nos adentraremos mucho en la definici\u00f3n te\u00f3rica de la comunicaci\u00f3n serie ni en sus especificaciones t\u00e9cnicas. Existe en Internet una gran cantidad de informaci\u00f3n muy detallada al respecto y para nuestro cometido, que es aprender a manejar Arduino y poder usarlo para nuestros propios proyectos, no nos interesa complicarnos. Nuestra intenci\u00f3n es hacer accesible, f\u00e1cil y divertido el mundo Arduino. Una vez comentado esto, definiremos la comunicaci\u00f3n serie como una \u201cinterfaz de comunicaci\u00f3n de datos digitales que nos permite establecer transferencia de informaci\u00f3n entre varios dispositivos\u201d. Esto nos va a permitir interactuar con nuestro Arduino, recibiendo informaci\u00f3n y envi\u00e1ndosela nosotros cuando lo necesitemos. Otra cosa que nos ser\u00e1 muy \u00fatil de esta comunicaci\u00f3n, es que podremos darle las \u00f3rdenes, previamente programadas, que queramos. 2.- \u00bfD\u00f3nde tenemos que dirigirnos para comunicarnos en serie con Arduino? Para poder establecer esta comunicaci\u00f3n usaremos el monitor serial que tenemos en el IDE. Lo encontraremos pulsando el bot\u00f3n , con el mismo nombre, que tenemos arriba a la derecha. Ilustraci\u00f3n 1 Bot\u00f3n de Monitor Serial Una vez que lo pulsemos, se abrir\u00e1 el monitor en el que podremos recibir informaci\u00f3n de Arduino y escribirle nosotros, tanto informaci\u00f3n que nos solicite como \u00f3rdenes. Ilustraci\u00f3n 2 Monitor Serial 3.- Conexiones serie en Arduino En la mayor\u00eda de Arduinos podemos encontrar 2 tipos de conexi\u00f3n serie para las comunicaciones. Primero, tendremos los pines de transmisi\u00f3n serie, que en Arduino UNO son los pines 0 (RX) para recibir datos y 1 (TX) para transmitirlos. Con ellos podremos, por ejemplo, conectar 2 Arduinos entre s\u00ed, conect\u00e1ndolos de manera cruzada, para que trabajen en paralelo o conectar un Arduino con otro dispositivo que tambi\u00e9n se comunique con este protocolo. Por razones obvias no podremos usar estos pines como salidas digitales mientras los usemos como conexi\u00f3n serial. En segundo lugar, tenemos los puertos USB (Universal Serial Bus) propios de las placas Arduino. Estos puertos, al trabajar con protocolo serial, los podemos usar para conectarnos al PC directamente y facilitarnos as\u00ed el conexionado de Arduino con \u00e9ste. 4.- Ejemplo: Ordenar a Arduino que encienda un Led Para entender mejor todo lo explicado, vamos a realizar un ejemplito muy sencillo pero que nos sirve para darnos cuenta de lo \u00fatil y potente que es esta caracter\u00edstica de Arduino. Comenzaremos realizando una simplificaci\u00f3n del esquema de montaje que utilizamos en el post 3 para el sem\u00e1foro, utilizando los mismos elementos pero para un solo Led. Ilustraci\u00f3n 3 Montaje para encender Led Una vez hemos montado el circuito, nos dirigimos al IDE y escribimos el siguiente c\u00f3digo, lo enviamos a nuestro Arduino y una vez terminado el proceso haremos click en el bot\u00f3n del monitor serial. /********************************/ /* Ordenar Parpadeos de un Led */ /********************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int parpadeos; int led = 2; //** Programa **// void setup(){ Serial.begin(9600); // Inicia la comunicaci\u00f3n serial pinMode(led, OUTPUT); } void loop(){ if (Serial.available()>0){ // Comprueba si el serial est\u00e1 disponible parpadeos = Serial.read()-48; // leemos el n\u00famero de parpadeos if (parpadeos >= 1 && parpadeos <= 9) // Si el valor introducido est\u00e1 entre 1 y 9 { Serial.print(\"Se van a dar \"); Serial.print(parpadeos); Serial.println(\" parpadeos\"); delay(1500); for(int i=0;i<parpadeos;i++){ // Realiza los parpadeos digitalWrite(led, HIGH); delay(100); digitalWrite(led, LOW); delay(200); } } else { // Si introducimos un valor erroneo Serial.println(\"El dato introducido es incorrecto\"); } } } Este programa lo que hace es que nuestro Led parpadee el n\u00famero de veces que le digamos. Para ello introduciremos valores, entre 1 y 9, por el monitor serial y pulsamos enter. Para realizar el c\u00f3digo, en primer lugar, hemos declarado las variables que vamos a usar, como en anteriores ejemplos. En la zona de setup hemos iniciado la comunicaci\u00f3n serial con el comando \u201c Serial.begin(9600) \u201d para que Arduino sepa que nos comunicaremos con \u00e9l a la velocidad de 9600 bits/seg (la velocidad es variable siempre que se establezca la misma en el c\u00f3digo y en el receptor de la se\u00f1al). Esto es necesario ponerlo siempre que vayamos a usar el monitor serial, ya que sin esta l\u00ednea Arduino no se comunicar\u00e1 por serial. Tambi\u00e9n hemos configurado nuestro pin del Led como salida. Usaremos el pin 2 . En el cuerpo de la funci\u00f3n loop, comenzamos con la funci\u00f3n \u201c if (Serial.available()>0) \u201d que comprueba si hemos enviado datos por serial para que, en nuestro caso, solo nos devuelva datos cuando los pedimos. Una vez enviado el n\u00famero, con la expresi\u00f3n \u201c parpadeos = Serial.read()-48 \u201d almacenaremos el valor que hemos enviado en la variable \u201c parpadeos \u201d. Como habr\u00e9is observado, al valor que lee del serial le restamos 48. Esto es debido a que Arduino lee los caracteres en c\u00f3digo ASCII, el cual pod\u00e9is ver aqu\u00ed , y en este c\u00f3digo el n\u00famero cero equivale al valor 48. De esta forma transformamos los n\u00fameros de ASCII a decimales. Continuaremos con \u201c if (parpadeos >= 1 && parpadeos <= 9) \u201d imponiendo que el programa solo funcione si introducimos un n\u00famero mayor o igual 1 y menor o igual 9, en caso contrario nos devolver\u00e1 el mensaje \u201c El dato introducido es incorrecto \u201d. Mediante la funci\u00f3n \u201c Serial.print() \u201d Arduino nos imprimir\u00e1 en el monitor serial lo que pongamos dentro del par\u00e9ntesis. Ya sea una frase, que habremos de introducir entre comillas Serial.print(\u201cfrase\u201d) , o una variable, para lo que pondremos directamente su nombre sin comillas Serial.print(variable) . Escrito as\u00ed nos ir\u00e1 imprimiendo todo en la misma l\u00ednea, pero si escribimos \u201c Serial.print ln () \u201d lo que haremos ser\u00e1 que, tras esa impresi\u00f3n, la siguiente se empezar\u00e1 a escribir en la l\u00ednea de abajo. Usaremos esta funci\u00f3n para que Arduino se comunique con nosotros. Finalmente definiremos un bucle for. En nuestro caso \u201c for (int i=0;i<parpadeos;i++) \u201d, para que iniciando el valor de \u201c i \u201d en 0, si \u201c i \u201d es menor que el valor de parpadeos introducido, encender\u00e1 y apagar\u00e1 el Led una vez e incrementar\u00e1 el valor de \u201c i \u201d en 1 cada vez que pase por el bucle. De esta forma conseguimos que el Led parpadee las veces que le hemos ordenado. Divertido \u00bfverdad?. 5.- Ejemplo: Reconocimiento de valores RGB por puerto serie En el siguiente ejemplo, utilizaremos la comunicaci\u00f3n serial para que Arduino nos d\u00e9 informaci\u00f3n, que necesitamos, de nuestro circuito. Le pediremos que nos d\u00e9 el valor que tienen 3 potenci\u00f3metros conectados a un Led RGB para saber el color exacto que est\u00e1 dando. \u00c9ste es un ejemplo bastante usado en distintos cursos para ense\u00f1ar c\u00f3mo funciona la comunicaci\u00f3n serial en Arduino, pero nos parece \u00fatil y divertido realizarlo con vosotros. Con este circuito, controlaremos qu\u00e9 cantidad de rojo, verde y azul dar\u00e1 nuestro Led y adem\u00e1s, gracias a la comunicaci\u00f3n serial, Arduino nos dir\u00e1 que color exacto est\u00e1 dando y podremos usar estos datos con otros programas o decirle nosotros al sistema que d\u00e9 un color exacto que queremos. Antes de comenzar, explicaremos que es un Led RGB . Es un Led que dentro lleva 3 colores independientes que mezclan su intensidad para proporcionar casi toda la gama de colores. Existen de dos tipos, de c\u00e1todo com\u00fan y de \u00e1nodo com\u00fan. Esto solo quiere decir que los 3 Leds internos que lleva el RGB comparten una de las conexiones, ya sea el c\u00e1todo que se conecta a tierra o el \u00e1nodo que se conecta a la alimentaci\u00f3n. Es f\u00e1cil identificar cual es la conexi\u00f3n compartida, ya que estos Leds tienen 4 filamentos y el m\u00e1s largo es el com\u00fan. Los otros 3 filamentos son los que controlan cada color. Da igual el tipo que usemos, siempre que los conectemos correctamente. Ilustraci\u00f3n 4 Conexiones de Led RGB (arduino utfsm) Para realizar este ejemplo necesitaremos los siguientes elementos: \u2022 1 x Arduino UNO R3 \u2022 1 X Protoboard \u2022 1 x led RGB (de c\u00e1todo com\u00fan) \u2022 3 x Resistencia de 220\u2126 (puede valer de 330\u2126) \u2022 3 x Potenci\u00f3metros lineales de 10k\u2126 \u2022 Cables para conectar todo El circuito que debemos montar es el siguiente: Ilustraci\u00f3n 5 Montaje de control de Led RGB Hay que resaltar, que conectaremos cada \u00e1nodo a pines digitales PWM del Arduino para controlar la intensidad que enviamos a cada uno. Nosotros usaremos los pines digitales 3, 5 y 6 , y los anal\u00f3gicos 0, 1, y 2 . Finalmente nos dirigiremos al IDE, escribiremos el siguiente c\u00f3digo y lo cargaremos a nuestro Arduino. Una vez cargado pulsaremos en el bot\u00f3n de monitor serial. /**********************************/ /* Control de Led RGB con Serial */ /**********************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// const int ledRojo=3; // definimos los pines digitales para el Led RGB const int ledVerde=5; const int ledAzul=6; const int potRojo=0; // definimos los pines analogicos para los potenciometros const int potVerde=1; const int potAzul=2; int rojo; // definimos variables para los valores de cada potenciometro int verde; int azul; //** Programa **// void setup(){ Serial.begin(9600); // inicia la comunicaci\u00f3n serial pinMode(ledRojo, OUTPUT); // configuramos los pines digitales como salida pinMode(ledVerde, OUTPUT); pinMode(ledAzul, OUTPUT); } void loop(){ rojo=analogRead(potRojo) / 4; // leemos el valor de cada potenci\u00f3metro verde=analogRead(potVerde) / 4; // y lo almacenamos azul=analogRead(potAzul) / 4; analogWrite(ledRojo,rojo); analogWrite(ledVerde,verde); analogWrite(ledAzul,azul); Serial.print(\"ROJO: \"); Serial.print(rojo); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-rojo Serial.print(\" / \"); Serial.print(\"VERDE: \"); Serial.print(verde); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-verde Serial.print(\" / \"); Serial.print(\"AZUL: \"); Serial.println(azul); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-azul delay(300); } Si prestamos atenci\u00f3n al c\u00f3digo, vemos que no tenemos funciones que no conozcamos. Solo destacar que, como la funci\u00f3n analogRead lee valores entre 0-1023 y analogWrite los escribe entre 0-255, para transformar los valores de uno a otro dividiremos el valor le\u00eddo por analogRead entre 4 para obtener una relaci\u00f3n aproximada y suficientemente buena. El resto del programa, con lo aprendido en los post anteriores, se entiende perfectamente. Una vez que tenemos todo listo, podemos ver c\u00f3mo, mientras movemos los potenci\u00f3metros, el Led RGB va creando distintos colores y en el monitor serial nos aparecen los valores de intensidad que se est\u00e1n utilizando para conseguirlos. Con estos valores podemos dirigirnos a cualquier programa de edici\u00f3n gr\u00e1fica y utilizar ese color exacto, o viceversa. Probaremos a conseguir el color del logo de OpenWebinars.net . Primero, abrimos el logo con Paint y haremos clic en la herramienta \u201cSelector de color\u201d. Picaremos en el color del logo y despu\u00e9s pulsaremos en \u201cEditar colores\u201d. En la ventana emergente ya podremos ver los valores RGB de nuestro color. Ilustraci\u00f3n 6 Selecci\u00f3n de valores RGB de una imagen usando Paint Ahora, si metemos esos valores en Arduino utilizando los potenci\u00f3metros, nuestro Led RGB brillar\u00e1 con el color que busc\u00e1bamos. Podemos jugar con los colores y usarlos como m\u00e1s nos diviertan. Ilustraci\u00f3n 7 Montaje de control Led RGB","title":"07 comunicacion serie"},{"location":"07_comunicacion_serie/#1-que-es-la-comunicacion-serie","text":"Antes de comenzar, aclararemos que no nos adentraremos mucho en la definici\u00f3n te\u00f3rica de la comunicaci\u00f3n serie ni en sus especificaciones t\u00e9cnicas. Existe en Internet una gran cantidad de informaci\u00f3n muy detallada al respecto y para nuestro cometido, que es aprender a manejar Arduino y poder usarlo para nuestros propios proyectos, no nos interesa complicarnos. Nuestra intenci\u00f3n es hacer accesible, f\u00e1cil y divertido el mundo Arduino. Una vez comentado esto, definiremos la comunicaci\u00f3n serie como una \u201cinterfaz de comunicaci\u00f3n de datos digitales que nos permite establecer transferencia de informaci\u00f3n entre varios dispositivos\u201d. Esto nos va a permitir interactuar con nuestro Arduino, recibiendo informaci\u00f3n y envi\u00e1ndosela nosotros cuando lo necesitemos. Otra cosa que nos ser\u00e1 muy \u00fatil de esta comunicaci\u00f3n, es que podremos darle las \u00f3rdenes, previamente programadas, que queramos.","title":"1.- \u00bfQu\u00e9 es la comunicaci\u00f3n serie?"},{"location":"07_comunicacion_serie/#2-donde-tenemos-que-dirigirnos-para-comunicarnos-en-serie-con-arduino","text":"Para poder establecer esta comunicaci\u00f3n usaremos el monitor serial que tenemos en el IDE. Lo encontraremos pulsando el bot\u00f3n , con el mismo nombre, que tenemos arriba a la derecha. Ilustraci\u00f3n 1 Bot\u00f3n de Monitor Serial Una vez que lo pulsemos, se abrir\u00e1 el monitor en el que podremos recibir informaci\u00f3n de Arduino y escribirle nosotros, tanto informaci\u00f3n que nos solicite como \u00f3rdenes. Ilustraci\u00f3n 2 Monitor Serial","title":"2.- \u00bfD\u00f3nde tenemos que dirigirnos para comunicarnos en serie con Arduino?"},{"location":"07_comunicacion_serie/#_1","text":"","title":""},{"location":"07_comunicacion_serie/#3-conexiones-serie-en-arduino","text":"En la mayor\u00eda de Arduinos podemos encontrar 2 tipos de conexi\u00f3n serie para las comunicaciones. Primero, tendremos los pines de transmisi\u00f3n serie, que en Arduino UNO son los pines 0 (RX) para recibir datos y 1 (TX) para transmitirlos. Con ellos podremos, por ejemplo, conectar 2 Arduinos entre s\u00ed, conect\u00e1ndolos de manera cruzada, para que trabajen en paralelo o conectar un Arduino con otro dispositivo que tambi\u00e9n se comunique con este protocolo. Por razones obvias no podremos usar estos pines como salidas digitales mientras los usemos como conexi\u00f3n serial. En segundo lugar, tenemos los puertos USB (Universal Serial Bus) propios de las placas Arduino. Estos puertos, al trabajar con protocolo serial, los podemos usar para conectarnos al PC directamente y facilitarnos as\u00ed el conexionado de Arduino con \u00e9ste.","title":"3.- Conexiones serie en Arduino"},{"location":"07_comunicacion_serie/#4-ejemplo-ordenar-a-arduino-que-encienda-un-led","text":"Para entender mejor todo lo explicado, vamos a realizar un ejemplito muy sencillo pero que nos sirve para darnos cuenta de lo \u00fatil y potente que es esta caracter\u00edstica de Arduino. Comenzaremos realizando una simplificaci\u00f3n del esquema de montaje que utilizamos en el post 3 para el sem\u00e1foro, utilizando los mismos elementos pero para un solo Led. Ilustraci\u00f3n 3 Montaje para encender Led Una vez hemos montado el circuito, nos dirigimos al IDE y escribimos el siguiente c\u00f3digo, lo enviamos a nuestro Arduino y una vez terminado el proceso haremos click en el bot\u00f3n del monitor serial. /********************************/ /* Ordenar Parpadeos de un Led */ /********************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// int parpadeos; int led = 2; //** Programa **// void setup(){ Serial.begin(9600); // Inicia la comunicaci\u00f3n serial pinMode(led, OUTPUT); } void loop(){ if (Serial.available()>0){ // Comprueba si el serial est\u00e1 disponible parpadeos = Serial.read()-48; // leemos el n\u00famero de parpadeos if (parpadeos >= 1 && parpadeos <= 9) // Si el valor introducido est\u00e1 entre 1 y 9 { Serial.print(\"Se van a dar \"); Serial.print(parpadeos); Serial.println(\" parpadeos\"); delay(1500); for(int i=0;i<parpadeos;i++){ // Realiza los parpadeos digitalWrite(led, HIGH); delay(100); digitalWrite(led, LOW); delay(200); } } else { // Si introducimos un valor erroneo Serial.println(\"El dato introducido es incorrecto\"); } } } Este programa lo que hace es que nuestro Led parpadee el n\u00famero de veces que le digamos. Para ello introduciremos valores, entre 1 y 9, por el monitor serial y pulsamos enter. Para realizar el c\u00f3digo, en primer lugar, hemos declarado las variables que vamos a usar, como en anteriores ejemplos. En la zona de setup hemos iniciado la comunicaci\u00f3n serial con el comando \u201c Serial.begin(9600) \u201d para que Arduino sepa que nos comunicaremos con \u00e9l a la velocidad de 9600 bits/seg (la velocidad es variable siempre que se establezca la misma en el c\u00f3digo y en el receptor de la se\u00f1al). Esto es necesario ponerlo siempre que vayamos a usar el monitor serial, ya que sin esta l\u00ednea Arduino no se comunicar\u00e1 por serial. Tambi\u00e9n hemos configurado nuestro pin del Led como salida. Usaremos el pin 2 . En el cuerpo de la funci\u00f3n loop, comenzamos con la funci\u00f3n \u201c if (Serial.available()>0) \u201d que comprueba si hemos enviado datos por serial para que, en nuestro caso, solo nos devuelva datos cuando los pedimos. Una vez enviado el n\u00famero, con la expresi\u00f3n \u201c parpadeos = Serial.read()-48 \u201d almacenaremos el valor que hemos enviado en la variable \u201c parpadeos \u201d. Como habr\u00e9is observado, al valor que lee del serial le restamos 48. Esto es debido a que Arduino lee los caracteres en c\u00f3digo ASCII, el cual pod\u00e9is ver aqu\u00ed , y en este c\u00f3digo el n\u00famero cero equivale al valor 48. De esta forma transformamos los n\u00fameros de ASCII a decimales. Continuaremos con \u201c if (parpadeos >= 1 && parpadeos <= 9) \u201d imponiendo que el programa solo funcione si introducimos un n\u00famero mayor o igual 1 y menor o igual 9, en caso contrario nos devolver\u00e1 el mensaje \u201c El dato introducido es incorrecto \u201d. Mediante la funci\u00f3n \u201c Serial.print() \u201d Arduino nos imprimir\u00e1 en el monitor serial lo que pongamos dentro del par\u00e9ntesis. Ya sea una frase, que habremos de introducir entre comillas Serial.print(\u201cfrase\u201d) , o una variable, para lo que pondremos directamente su nombre sin comillas Serial.print(variable) . Escrito as\u00ed nos ir\u00e1 imprimiendo todo en la misma l\u00ednea, pero si escribimos \u201c Serial.print ln () \u201d lo que haremos ser\u00e1 que, tras esa impresi\u00f3n, la siguiente se empezar\u00e1 a escribir en la l\u00ednea de abajo. Usaremos esta funci\u00f3n para que Arduino se comunique con nosotros. Finalmente definiremos un bucle for. En nuestro caso \u201c for (int i=0;i<parpadeos;i++) \u201d, para que iniciando el valor de \u201c i \u201d en 0, si \u201c i \u201d es menor que el valor de parpadeos introducido, encender\u00e1 y apagar\u00e1 el Led una vez e incrementar\u00e1 el valor de \u201c i \u201d en 1 cada vez que pase por el bucle. De esta forma conseguimos que el Led parpadee las veces que le hemos ordenado. Divertido \u00bfverdad?.","title":"4.- Ejemplo: Ordenar a Arduino que encienda un Led"},{"location":"07_comunicacion_serie/#5-ejemplo-reconocimiento-de-valores-rgb-por-puerto-serie","text":"En el siguiente ejemplo, utilizaremos la comunicaci\u00f3n serial para que Arduino nos d\u00e9 informaci\u00f3n, que necesitamos, de nuestro circuito. Le pediremos que nos d\u00e9 el valor que tienen 3 potenci\u00f3metros conectados a un Led RGB para saber el color exacto que est\u00e1 dando. \u00c9ste es un ejemplo bastante usado en distintos cursos para ense\u00f1ar c\u00f3mo funciona la comunicaci\u00f3n serial en Arduino, pero nos parece \u00fatil y divertido realizarlo con vosotros. Con este circuito, controlaremos qu\u00e9 cantidad de rojo, verde y azul dar\u00e1 nuestro Led y adem\u00e1s, gracias a la comunicaci\u00f3n serial, Arduino nos dir\u00e1 que color exacto est\u00e1 dando y podremos usar estos datos con otros programas o decirle nosotros al sistema que d\u00e9 un color exacto que queremos. Antes de comenzar, explicaremos que es un Led RGB . Es un Led que dentro lleva 3 colores independientes que mezclan su intensidad para proporcionar casi toda la gama de colores. Existen de dos tipos, de c\u00e1todo com\u00fan y de \u00e1nodo com\u00fan. Esto solo quiere decir que los 3 Leds internos que lleva el RGB comparten una de las conexiones, ya sea el c\u00e1todo que se conecta a tierra o el \u00e1nodo que se conecta a la alimentaci\u00f3n. Es f\u00e1cil identificar cual es la conexi\u00f3n compartida, ya que estos Leds tienen 4 filamentos y el m\u00e1s largo es el com\u00fan. Los otros 3 filamentos son los que controlan cada color. Da igual el tipo que usemos, siempre que los conectemos correctamente. Ilustraci\u00f3n 4 Conexiones de Led RGB (arduino utfsm) Para realizar este ejemplo necesitaremos los siguientes elementos: \u2022 1 x Arduino UNO R3 \u2022 1 X Protoboard \u2022 1 x led RGB (de c\u00e1todo com\u00fan) \u2022 3 x Resistencia de 220\u2126 (puede valer de 330\u2126) \u2022 3 x Potenci\u00f3metros lineales de 10k\u2126 \u2022 Cables para conectar todo El circuito que debemos montar es el siguiente: Ilustraci\u00f3n 5 Montaje de control de Led RGB Hay que resaltar, que conectaremos cada \u00e1nodo a pines digitales PWM del Arduino para controlar la intensidad que enviamos a cada uno. Nosotros usaremos los pines digitales 3, 5 y 6 , y los anal\u00f3gicos 0, 1, y 2 . Finalmente nos dirigiremos al IDE, escribiremos el siguiente c\u00f3digo y lo cargaremos a nuestro Arduino. Una vez cargado pulsaremos en el bot\u00f3n de monitor serial. /**********************************/ /* Control de Led RGB con Serial */ /**********************************/ /*** Fernando Martinez Mendoza ***/ //** Definiciones **// const int ledRojo=3; // definimos los pines digitales para el Led RGB const int ledVerde=5; const int ledAzul=6; const int potRojo=0; // definimos los pines analogicos para los potenciometros const int potVerde=1; const int potAzul=2; int rojo; // definimos variables para los valores de cada potenciometro int verde; int azul; //** Programa **// void setup(){ Serial.begin(9600); // inicia la comunicaci\u00f3n serial pinMode(ledRojo, OUTPUT); // configuramos los pines digitales como salida pinMode(ledVerde, OUTPUT); pinMode(ledAzul, OUTPUT); } void loop(){ rojo=analogRead(potRojo) / 4; // leemos el valor de cada potenci\u00f3metro verde=analogRead(potVerde) / 4; // y lo almacenamos azul=analogRead(potAzul) / 4; analogWrite(ledRojo,rojo); analogWrite(ledVerde,verde); analogWrite(ledAzul,azul); Serial.print(\"ROJO: \"); Serial.print(rojo); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-rojo Serial.print(\" / \"); Serial.print(\"VERDE: \"); Serial.print(verde); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-verde Serial.print(\" / \"); Serial.print(\"AZUL: \"); Serial.println(azul); // si fuese \u00e1nodo com\u00fan ser\u00eda 255-azul delay(300); } Si prestamos atenci\u00f3n al c\u00f3digo, vemos que no tenemos funciones que no conozcamos. Solo destacar que, como la funci\u00f3n analogRead lee valores entre 0-1023 y analogWrite los escribe entre 0-255, para transformar los valores de uno a otro dividiremos el valor le\u00eddo por analogRead entre 4 para obtener una relaci\u00f3n aproximada y suficientemente buena. El resto del programa, con lo aprendido en los post anteriores, se entiende perfectamente. Una vez que tenemos todo listo, podemos ver c\u00f3mo, mientras movemos los potenci\u00f3metros, el Led RGB va creando distintos colores y en el monitor serial nos aparecen los valores de intensidad que se est\u00e1n utilizando para conseguirlos. Con estos valores podemos dirigirnos a cualquier programa de edici\u00f3n gr\u00e1fica y utilizar ese color exacto, o viceversa. Probaremos a conseguir el color del logo de OpenWebinars.net . Primero, abrimos el logo con Paint y haremos clic en la herramienta \u201cSelector de color\u201d. Picaremos en el color del logo y despu\u00e9s pulsaremos en \u201cEditar colores\u201d. En la ventana emergente ya podremos ver los valores RGB de nuestro color. Ilustraci\u00f3n 6 Selecci\u00f3n de valores RGB de una imagen usando Paint Ahora, si metemos esos valores en Arduino utilizando los potenci\u00f3metros, nuestro Led RGB brillar\u00e1 con el color que busc\u00e1bamos. Podemos jugar con los colores y usarlos como m\u00e1s nos diviertan. Ilustraci\u00f3n 7 Montaje de control Led RGB","title":"5.- Ejemplo: Reconocimiento de valores RGB por puerto serie"},{"location":"08_sonidos/","text":"Sonidos con Arduino Funci\u00f3n tone Con Arduino tambi\u00e9n podemos crear sonidos gracias a la funci\u00f3n tone cuya sintaxis es la siguiente: tone(pinsalida,frecuencia); Esta funci\u00f3n lo que hace es intercambiar valores HIGH/LOW a la frecuencia deseada en el pin seleccionado hasta que la volvemos a llamar con otra frecuencia o le ordenamos que pare con esta funci\u00f3n noTone(pinsalida); Tenemos que tener en cuenta que s\u00f3lo es capaz de generar un \u00fanico tono a la vez . Si llamamos a la funci\u00f3n tone para que genere sonidos en otro pin sin haber detenido el que est\u00e1 sonando no ocurrir\u00e1 nada. Zumbador Un zumbador es un elemento parecido a un altavoz pero s\u00f3lo emite zumbidos (t\u00edpico sonido que emiten los electrodom\u00e9sticos). Su precio suele rondar los 2\u20ac . Para hacerlo sonar utilizaremos los pines 13 y GND. El montaje no merece m\u00e1s explicaci\u00f3n que la de la imagen. Ya s\u00f3lo falta crear el c\u00f3digo y cargarlo. En la funci\u00f3n loop hacemos la llamada a tone para que suene y noTone para detener el sonido. Cambiando los valores de la funci\u00f3n delay haremos que suene durante m\u00e1s o menos tiempo. int pinzumbador = 13; // pin del zumbador int frecuencia = 220; // frecuencia correspondiente a la nota La void setup() { } void loop() { tone(pinzumbador,frecuencia); // inicia el zumbido delay(2000); noTone(pinzumbador); // lo detiene a los dos segundos delay(1000); } Podemos observar dos cosas: Al cargar el programa suena brevemente el zumbador. Esto se debe a que utilizamos el pin 13 y \u00e9ste se pone a HIGH brevemente unas veces cuando se inicia la placa. Si variamos la frecuencia a penas var\u00eda el tono o no suena. La causa de \u00e9sto es que un zumbador tiene poca capacidad para reproducir sonidos fielmente. La frecuencia influye tan poco que incluso sonar\u00eda conect\u00e1ndolo entre los pines 5V y GND. Para frecuencias demasiado altas el zumbador no responde. M\u00fasica En este punto utilizaremos un peque\u00f1o altavoz. Pod\u00e9is aprovechar uno que teng\u00e1is en alg\u00fan aparato que no utilic\u00e9is. El mismo montaje servir\u00e1 para los dos ejemplos siguientes. El primero consistir\u00e1 en reproducir una escala de 220 a 440 HZ con todos sus semitonos. En el segundo reproduciremos m\u00fasica. Si os fij\u00e1is en el esquema he puesto un condensador (~0.20\u20ac) en serie con el altavoz. \u00c9sto es para eliminar cualquier componente de continua. Tened en cuenta que si eleg\u00eds valores muy peque\u00f1os puede recortar las frecuencias m\u00e1s bajas. Con valores de 47 uF o mayores va bien. IMPORTANTE: Si us\u00e1is condensadores electrol\u00edticos (los cil\u00edndricos) ten\u00e9is que tener en cuenta que tienen polaridad y si lo coloc\u00e1is al rev\u00e9s pueden explotar . Fijaros que tienen una franja con signos \u201c-\u201d en la pata negativa. Vamos con el primer ejemplo. Para no almacenar todas las frecuencias y tener que escribir la funci\u00f3n tone en nuestro c\u00f3digo cada vez que queramos una nueva nota, haremos un peque\u00f1o truco. Almacenaremos s\u00f3lo el valor de la frecuencia inicial, y las sucesivas notas tendr\u00e1n la frecuencia de la anterior multiplicada por 1,059. De este modo escribiremos una sola vez la funci\u00f3n para hacerlo sonar y un bucle for ser\u00e1 el encargado de ir incrementando el valor de la frecuencia. /***********************/ /* recorrido de octava */ /***********************/ int pinaltavoz = 13; int frecuencia=220; // frecuencia correspondiente a la nota La int contador; // variable para el contador float m=1.059; // constante para multiplicar frecuencias void setup() { } void loop() { for(contador=0,frecuencia=220;contador<12;contador++) { frecuencia=frecuencia*m; // actualiza la frecuencia tone(pinaltavoz,frecuencia); // emite el tono delay(1500); // lo mantiene 1.5 segundos noTone(pinaltavoz); // para el tono delay(500); // espera medio segundo } } Ahora pasamos a lo bueno: reproducir m\u00fasica , pero de la que recuerda a los videojuegos con m\u00fasica de 8 bits. En este c\u00f3digo utilizaremos una funci\u00f3n auxiliar que llamaremos not a con la siguiente estructura nota(frecuencia,duraci\u00f3n); La ventaja es que nos ahorrar\u00e1 escribir decenas de veces la funci\u00f3n delay para indicar el tiempo que debe durar la nota. Cada vez que llamemos a esa funci\u00f3n se ejecutar\u00e1 esta parte del c\u00f3digo void nota(int frec, int t) { tone(spk,frec); // suena la nota frec recibida delay(t); // para despues de un tiempo t } Os dejo varios fragmentos de canciones. Pod\u00e9is buscar partituras de canciones y pasar las notas a frecuencia y tiempo. /**************************/ /* popurri para Arduino */ /**************************/ /**************** Antonio Guillermo P\u00e9rez Coronilla ***************/ /* declaraci\u00f3n de variables */ int spk=13; // altavoz a GND y pin 13 int c[5]={131,262,523,1046,2093}; // frecuencias 4 octavas de Do int cs[5]={139,277,554,1108,2217}; // Do# int d[5]={147,294,587,1175,2349}; // Re int ds[5]={156,311,622,1244,2489}; // Re# int e[5]={165,330,659,1319,2637}; // Mi int f[5]={175,349,698,1397,2794}; // Fa int fs[5]={185,370,740,1480,2960}; // Fa# int g[5]={196,392,784,1568,3136}; // Sol int gs[5]={208,415,831,1661,3322}; // Sol# int a[5]={220,440,880,1760,3520}; // La int as[5]={233,466,932,1866,3729}; // La# int b[5]={247,494,988,1976,3951}; // Si void nota(int a, int b); // declaraci\u00f3n de la funci\u00f3n auxiliar. Recibe dos n\u00fameros enteros. void setup() { /**************************************/ /* HARRY POTTER */ /**************************************/ nota(b[2], 500); nota(e[3],1000); nota(g[3], 250); nota(fs[3],250); nota(e[3],1000); nota(b[3],500); nota(a[3],1250); nota(fs[3],1000); nota(b[2], 500); nota(e[3],1000); nota(g[3],250); nota(fs[3],250); nota(d[3],1000); nota(e[3],500 ); nota(b[2],1000 ); noTone(spk); delay(1000); nota(b[2], 500); nota(e[3],1000); nota(g[3], 250); nota(fs[3],250); nota(e[3],1000); nota(b[3],500); nota(d[4],1000); nota(cs[4],500); nota(c[4],1000); nota(a[3],500); nota(c[4],1000); nota(b[3],250); nota(as[3],250); nota(b[2],1000); nota(g[3],500); nota(e[3],1000); noTone(spk); delay(2000); /*******************/ /* STAR WARS */ /*******************/ /**** tema principal ****/ nota(d[1],150);noTone(spk);delay(50); nota(d[1],150);noTone(spk);delay(50); nota(d[1],150);noTone(spk);delay(50); nota(g[1],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(50); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(a[1],150);noTone(spk);delay(50); nota(g[2],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(100); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(a[1],150);noTone(spk);delay(50); nota(g[2],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(100); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(c[2],150);noTone(spk);delay(50); nota(a[1],1200);noTone(spk);delay(2000); /**** marcha del imperio ****/ nota(g[2],500);noTone(spk);delay(100); nota(g[2],500);noTone(spk);delay(100); nota(g[2],500);noTone(spk);delay(100); nota(ds[2],500);noTone(spk);delay(1); nota(as[2],125);noTone(spk);delay(25); nota(g[2],500);noTone(spk);delay(100); nota(ds[2],500);noTone(spk);delay(1); nota(as[2],125);noTone(spk);delay(25); nota(g[2],500); noTone(spk);delay(2000); /**********************/ /* entre dos aguas */ /**********************/ nota(a[1],400);noTone(spk);delay(400); nota(e[1],400);noTone(spk);delay(400); nota(a[1],400);noTone(spk);delay(200); nota(e[1],200);noTone(spk);delay(200); nota(a[1],200);noTone(spk);delay(200); nota(as[1],100);noTone(spk);delay(100); nota(b[1],400);noTone(spk);delay(400); nota(fs[1],400);noTone(spk);delay(400); nota(b[1],400);noTone(spk);delay(200); nota(fs[1],200);noTone(spk);delay(200); nota(b[1],200);noTone(spk);delay(200); nota(as[1],100);noTone(spk);delay(100); nota(a[1],400);noTone(spk);delay(400); nota(e[1],400);noTone(spk);delay(400); nota(a[1],400);noTone(spk);delay(400); } void nota(int frec, int t) { tone(spk,frec); // suena la nota frec recibida delay(t); // para despues de un tiempo t } void loop() { }","title":"08 sonidos"},{"location":"08_sonidos/#sonidos-con-arduino","text":"Funci\u00f3n tone Con Arduino tambi\u00e9n podemos crear sonidos gracias a la funci\u00f3n tone cuya sintaxis es la siguiente: tone(pinsalida,frecuencia); Esta funci\u00f3n lo que hace es intercambiar valores HIGH/LOW a la frecuencia deseada en el pin seleccionado hasta que la volvemos a llamar con otra frecuencia o le ordenamos que pare con esta funci\u00f3n noTone(pinsalida); Tenemos que tener en cuenta que s\u00f3lo es capaz de generar un \u00fanico tono a la vez . Si llamamos a la funci\u00f3n tone para que genere sonidos en otro pin sin haber detenido el que est\u00e1 sonando no ocurrir\u00e1 nada. Zumbador Un zumbador es un elemento parecido a un altavoz pero s\u00f3lo emite zumbidos (t\u00edpico sonido que emiten los electrodom\u00e9sticos). Su precio suele rondar los 2\u20ac . Para hacerlo sonar utilizaremos los pines 13 y GND. El montaje no merece m\u00e1s explicaci\u00f3n que la de la imagen. Ya s\u00f3lo falta crear el c\u00f3digo y cargarlo. En la funci\u00f3n loop hacemos la llamada a tone para que suene y noTone para detener el sonido. Cambiando los valores de la funci\u00f3n delay haremos que suene durante m\u00e1s o menos tiempo. int pinzumbador = 13; // pin del zumbador int frecuencia = 220; // frecuencia correspondiente a la nota La void setup() { } void loop() { tone(pinzumbador,frecuencia); // inicia el zumbido delay(2000); noTone(pinzumbador); // lo detiene a los dos segundos delay(1000); } Podemos observar dos cosas: Al cargar el programa suena brevemente el zumbador. Esto se debe a que utilizamos el pin 13 y \u00e9ste se pone a HIGH brevemente unas veces cuando se inicia la placa. Si variamos la frecuencia a penas var\u00eda el tono o no suena. La causa de \u00e9sto es que un zumbador tiene poca capacidad para reproducir sonidos fielmente. La frecuencia influye tan poco que incluso sonar\u00eda conect\u00e1ndolo entre los pines 5V y GND. Para frecuencias demasiado altas el zumbador no responde. M\u00fasica En este punto utilizaremos un peque\u00f1o altavoz. Pod\u00e9is aprovechar uno que teng\u00e1is en alg\u00fan aparato que no utilic\u00e9is. El mismo montaje servir\u00e1 para los dos ejemplos siguientes. El primero consistir\u00e1 en reproducir una escala de 220 a 440 HZ con todos sus semitonos. En el segundo reproduciremos m\u00fasica. Si os fij\u00e1is en el esquema he puesto un condensador (~0.20\u20ac) en serie con el altavoz. \u00c9sto es para eliminar cualquier componente de continua. Tened en cuenta que si eleg\u00eds valores muy peque\u00f1os puede recortar las frecuencias m\u00e1s bajas. Con valores de 47 uF o mayores va bien. IMPORTANTE: Si us\u00e1is condensadores electrol\u00edticos (los cil\u00edndricos) ten\u00e9is que tener en cuenta que tienen polaridad y si lo coloc\u00e1is al rev\u00e9s pueden explotar . Fijaros que tienen una franja con signos \u201c-\u201d en la pata negativa. Vamos con el primer ejemplo. Para no almacenar todas las frecuencias y tener que escribir la funci\u00f3n tone en nuestro c\u00f3digo cada vez que queramos una nueva nota, haremos un peque\u00f1o truco. Almacenaremos s\u00f3lo el valor de la frecuencia inicial, y las sucesivas notas tendr\u00e1n la frecuencia de la anterior multiplicada por 1,059. De este modo escribiremos una sola vez la funci\u00f3n para hacerlo sonar y un bucle for ser\u00e1 el encargado de ir incrementando el valor de la frecuencia. /***********************/ /* recorrido de octava */ /***********************/ int pinaltavoz = 13; int frecuencia=220; // frecuencia correspondiente a la nota La int contador; // variable para el contador float m=1.059; // constante para multiplicar frecuencias void setup() { } void loop() { for(contador=0,frecuencia=220;contador<12;contador++) { frecuencia=frecuencia*m; // actualiza la frecuencia tone(pinaltavoz,frecuencia); // emite el tono delay(1500); // lo mantiene 1.5 segundos noTone(pinaltavoz); // para el tono delay(500); // espera medio segundo } } Ahora pasamos a lo bueno: reproducir m\u00fasica , pero de la que recuerda a los videojuegos con m\u00fasica de 8 bits. En este c\u00f3digo utilizaremos una funci\u00f3n auxiliar que llamaremos not a con la siguiente estructura nota(frecuencia,duraci\u00f3n); La ventaja es que nos ahorrar\u00e1 escribir decenas de veces la funci\u00f3n delay para indicar el tiempo que debe durar la nota. Cada vez que llamemos a esa funci\u00f3n se ejecutar\u00e1 esta parte del c\u00f3digo void nota(int frec, int t) { tone(spk,frec); // suena la nota frec recibida delay(t); // para despues de un tiempo t } Os dejo varios fragmentos de canciones. Pod\u00e9is buscar partituras de canciones y pasar las notas a frecuencia y tiempo. /**************************/ /* popurri para Arduino */ /**************************/ /**************** Antonio Guillermo P\u00e9rez Coronilla ***************/ /* declaraci\u00f3n de variables */ int spk=13; // altavoz a GND y pin 13 int c[5]={131,262,523,1046,2093}; // frecuencias 4 octavas de Do int cs[5]={139,277,554,1108,2217}; // Do# int d[5]={147,294,587,1175,2349}; // Re int ds[5]={156,311,622,1244,2489}; // Re# int e[5]={165,330,659,1319,2637}; // Mi int f[5]={175,349,698,1397,2794}; // Fa int fs[5]={185,370,740,1480,2960}; // Fa# int g[5]={196,392,784,1568,3136}; // Sol int gs[5]={208,415,831,1661,3322}; // Sol# int a[5]={220,440,880,1760,3520}; // La int as[5]={233,466,932,1866,3729}; // La# int b[5]={247,494,988,1976,3951}; // Si void nota(int a, int b); // declaraci\u00f3n de la funci\u00f3n auxiliar. Recibe dos n\u00fameros enteros. void setup() { /**************************************/ /* HARRY POTTER */ /**************************************/ nota(b[2], 500); nota(e[3],1000); nota(g[3], 250); nota(fs[3],250); nota(e[3],1000); nota(b[3],500); nota(a[3],1250); nota(fs[3],1000); nota(b[2], 500); nota(e[3],1000); nota(g[3],250); nota(fs[3],250); nota(d[3],1000); nota(e[3],500 ); nota(b[2],1000 ); noTone(spk); delay(1000); nota(b[2], 500); nota(e[3],1000); nota(g[3], 250); nota(fs[3],250); nota(e[3],1000); nota(b[3],500); nota(d[4],1000); nota(cs[4],500); nota(c[4],1000); nota(a[3],500); nota(c[4],1000); nota(b[3],250); nota(as[3],250); nota(b[2],1000); nota(g[3],500); nota(e[3],1000); noTone(spk); delay(2000); /*******************/ /* STAR WARS */ /*******************/ /**** tema principal ****/ nota(d[1],150);noTone(spk);delay(50); nota(d[1],150);noTone(spk);delay(50); nota(d[1],150);noTone(spk);delay(50); nota(g[1],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(50); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(a[1],150);noTone(spk);delay(50); nota(g[2],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(100); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(a[1],150);noTone(spk);delay(50); nota(g[2],900);noTone(spk);delay(150); nota(d[2],900);noTone(spk);delay(100); nota(c[2],150);noTone(spk);delay(50); nota(b[1],150);noTone(spk);delay(50); nota(c[2],150);noTone(spk);delay(50); nota(a[1],1200);noTone(spk);delay(2000); /**** marcha del imperio ****/ nota(g[2],500);noTone(spk);delay(100); nota(g[2],500);noTone(spk);delay(100); nota(g[2],500);noTone(spk);delay(100); nota(ds[2],500);noTone(spk);delay(1); nota(as[2],125);noTone(spk);delay(25); nota(g[2],500);noTone(spk);delay(100); nota(ds[2],500);noTone(spk);delay(1); nota(as[2],125);noTone(spk);delay(25); nota(g[2],500); noTone(spk);delay(2000); /**********************/ /* entre dos aguas */ /**********************/ nota(a[1],400);noTone(spk);delay(400); nota(e[1],400);noTone(spk);delay(400); nota(a[1],400);noTone(spk);delay(200); nota(e[1],200);noTone(spk);delay(200); nota(a[1],200);noTone(spk);delay(200); nota(as[1],100);noTone(spk);delay(100); nota(b[1],400);noTone(spk);delay(400); nota(fs[1],400);noTone(spk);delay(400); nota(b[1],400);noTone(spk);delay(200); nota(fs[1],200);noTone(spk);delay(200); nota(b[1],200);noTone(spk);delay(200); nota(as[1],100);noTone(spk);delay(100); nota(a[1],400);noTone(spk);delay(400); nota(e[1],400);noTone(spk);delay(400); nota(a[1],400);noTone(spk);delay(400); } void nota(int frec, int t) { tone(spk,frec); // suena la nota frec recibida delay(t); // para despues de un tiempo t } void loop() { }","title":"Sonidos con Arduino"},{"location":"09_medicion_temperatura_ds18b20/","text":"\u00bfQu\u00e9 es el sistema OneWire? En este post, realizaremos un ejemplo de medici\u00f3n de temperatura con el sensor ds18b20 . Este sensor, aparte de tener una buena precisi\u00f3n y una versi\u00f3n sumergible, funciona utilizando un sistema de conexionado muy particular. Este sistema se denomina OneWire . Con \u00e9l conseguimos enviar y recibir datos por un \u00fanico cable. Esto tiene sus ventajas e inconvenientes, pero no deja de ser una opci\u00f3n muy a tener en cuenta cuando vamos justos de conexiones de control para nuestro proyecto, ya que nos ahorramos un cable en cada sensor. En otro ejemplo, ya realizamos mediciones de temperatura con un sensor. Lo interesante de este ejemplo no es el medir la temperatura, si no aprender el funcionamiento del sistema OneWire, para poder usarlo en cualquier sensor que lo utilice, y la instalaci\u00f3n e importado de librer\u00edas de terceros. Existen muchos detractores de este sistema, que ponen de manifiesto que el usarlo exige unos c\u00f3digos algo complicados\u2026y que el conexionado no es demasiado intuitivo\u2026 La verdad es que ni son tan complicados los c\u00f3digos, ya que las librer\u00edas propias y los ejemplos que traen estos sensores son una buena herramienta, ni es tan complicada su conexi\u00f3n, solo hay que seguir el esquema que os daremos posteriormente. Como ver\u00e9is en Internet, la mayor\u00eda de errores y problemas de las personas que los usan radican en un mal conexionado. \u00bfC\u00f3mo usar las librer\u00edas y los ejemplos? Esta vez, usaremos unas librer\u00edas en nuestro proyecto para controlar el sensor t\u00e9rmico con el sistema OneWire que os hemos comentado. En nuestro post 3, os definimos qu\u00e9 eran las librer\u00edas y ahora os explicaremos como usarlas. Arduino tiene una serie de librer\u00edas gen\u00e9ricas que podemos usar simplemente escribiendo al principio de nuestro c\u00f3digo la sentencia #include < librer\u00eda .h> repitiendo con todas las librer\u00edas que necesitemos. Ilustraci\u00f3n 1 Importaci\u00f3n de librer\u00edas en IDE Arduino En este ejemplo vamos a usar las librer\u00edas propias del sensor en cuesti\u00f3n, en nuestro caso usaremos las librer\u00edas DallasTemperature y OneWire . Para instalar las librer\u00edas propias, o de terceros, una vez descargadas existen 2 m\u00e9todos: 1. M\u00e9todo normal : Dentro del IDE, nos dirigimos a Sketch->Importar librer\u00eda->Ad library \u2026. Se nos abrir\u00e1 una ventana de exploraci\u00f3n en la que debemos buscar el archivo rar/zip que hemos descargado. Lo seleccionamos y ya la tendremos instalada. Ilustraci\u00f3n 2 Instalaci\u00f3n de librer\u00edas en IDE Arduino 2. M\u00e9todo manual : Si el m\u00e9todo anterior no funciona, utilizaremos la instalaci\u00f3n manual. Para proceder, descomprimiremos el rar/zip descargado y copiamos la carpeta de la librer\u00eda en la ruta Documentos\\Arduino\\libraries . Quedando, por ejemplo, de la siguiente manera. Ilustraci\u00f3n 3 Ejemplo de carpeta de librer\u00eda instalada Una vez instaladas las librer\u00edas que vayamos a usar, podremos usar los ejemplos que traen cada una para probar sus accesorios. Es interesante echarles un ojo antes de ponernos a programar como locos, porque de estos ejemplos podemos aprovechar partes de c\u00f3digo o ver c\u00f3mo usa las funciones\u2026 y as\u00ed ahorrarnos mucho trabajo. Para abrir estos ejemplos solo tendremos que dirigirnos dentro del IDE a Archivo->Ejemplos y ah\u00ed veremos todas las librer\u00edas disponibles y dentro de cada una, sus ejemplos correspondientes. Ilustraci\u00f3n 4 Cargar ejemplos Ejemplo: Medici\u00f3n de temperatura con sensor ds18b20 Para empezar con este ejemplo detallaremos el material necesario. \u2022 1 x Arduino UNO R3 \u2022 1 x Protoboard \u2022 1 x Sensor de Temperatura ds18b20 (versi\u00f3n sumergible) \u2022 1 x Resistencia de 4,7k\u2126 \u2022 Cables para conectar todo En esta ocasi\u00f3n, es muy importante que prest\u00e9is atenci\u00f3n al montaje del circuito. No es para nada dif\u00edcil, pero si no est\u00e1 correcto el sensor dar\u00e1 medidas err\u00f3neas o incluso puede estropearse. El esquema es el siguiente: Ilustraci\u00f3n 5 Montaje para el sensor ds18b20 Como observamos en el circuito, alimentaremos a trav\u00e9s del pin DATA, por medio de la resistencia de 4,7k\u2126, y los pines VCC y GND van conectados entre s\u00ed y a tierra. Aqu\u00ed en el datasheet del sensor pod\u00e9is ver c\u00f3mo va el patillaje, o bien si us\u00e1is la versi\u00f3n sumergible, como nosotros, la correspondencia de los 3 cables ser\u00eda: [Rojo]=VCC, [Azul o Negro] = GND y [Amarillo o Blanco] = DATA. Una vez conectado todo correctamente, nos dirigiremos al IDE y escribiremos el siguiente c\u00f3digo. /******************************/ /* Medir Temperatura ds18b20 */ /******************************/ /*** Librer\u00edas ***/ #include <OneWire.h> //Se importan las librer\u00edas #include <DallasTemperature.h> //** Definiciones **// #define Pin 2 //Se declara el pin donde se conectar\u00e1 la DATA OneWire ourWire(Pin); //Se establece el pin declarado como bus para la comunicaci\u00f3n OneWire DallasTemperature sensors(&ourWire); //Se llama a la librer\u00eda DallasTemperature //** Programa **// void setup() { delay(1000); Serial.begin(9600); sensors.begin(); //Se inician los sensores } void loop() { sensors.requestTemperatures(); //Prepara el sensor para la lectura Serial.print(sensors.getTempCByIndex(0)); //Se lee e imprime la temperatura en grados Centigrados Serial.println(\" Grados Centigrados\"); delay(1000); //Se provoca una parada de 1 segundo antes de la pr\u00f3xima lectura } (Panama hiteck) En el programa, simplemente comenzaremos importando las librer\u00edas, OneWire y DallasTemperature, de la forma que coment\u00e1bamos m\u00e1s arriba. Continuaremos definiendo el pin que utilizaremos como bus de datos. Para ello usaremos la sentencia #define , la cual nos permite crear un valor constante pero con la ventaja de no consumir la RAM que usar\u00eda, al compilar, la creaci\u00f3n de una variable. Hay que tener la precauci\u00f3n de escribir correctamente las definiciones por que pueden provocar el lastrado de errores a lo largo de todo el c\u00f3digo si no se hace bien. En nuestro caso asignaremos el pin 2 para el bus. Con la l\u00ednea OneWire ourWire(Pin) , le decimos al sensor a trav\u00e9s de que pin se debe comunicar con Arduino y con DallasTemperature sensors(&ourWire) llamaremos a la librer\u00eda de Dallas para que interprete los datos enviados y recibidos por nuestro bus. Seguidamente, en nuestra funci\u00f3n de setup, iniciaremos la comunicaci\u00f3n serial a 9600 bits/seg y con la sentencia sensors.begin() activaremos los sensores que estemos usando. Nuestro c\u00f3digo en bucle, lo que har\u00e1 ser\u00e1 primero preparar al sensor ds18b20 para medir, usando la funci\u00f3n sensors.requestTemperatures() y con la l\u00ednea Serial.print(sensors.getTempCByIndex(0)) tomar\u00e1 la medida y la imprimir\u00e1, por el monitor serial y en grados cent\u00edgrados, en una \u00fanica sentencia. Finalmente a\u00f1adiremos la impresi\u00f3n del texto \u201c Grados Cent\u00edgrados \u201d y haremos una pausa de 1 segundo para que el sensor no est\u00e9 realizando miles de medidas constantemente. Ilustraci\u00f3n 6 Visualizaci\u00f3n de la temperatura en el monitor serial Como hab\u00e9is podido comprobar, es muy sencillo y pr\u00e1ctico utilizar este sistema. Solo hay que familiarizarse con las funciones espec\u00edficas de la librer\u00eda de cada sensor para sacarles el m\u00e1ximo provecho. Os recomendamos que le\u00e1is que funciones espec\u00edficas trae cada librer\u00eda y jugu\u00e9is un poco con ellas antes de poneros a programar vuestro proyecto, seguro que encontrar\u00e9is algunas funciones o ejemplos propios que os simplifican el c\u00f3digo bastante. Ilustraci\u00f3n 7 Montaje para el sensor ds18b20","title":"09 medicion temperatura ds18b20"},{"location":"09_medicion_temperatura_ds18b20/#que-es-el-sistema-onewire","text":"En este post, realizaremos un ejemplo de medici\u00f3n de temperatura con el sensor ds18b20 . Este sensor, aparte de tener una buena precisi\u00f3n y una versi\u00f3n sumergible, funciona utilizando un sistema de conexionado muy particular. Este sistema se denomina OneWire . Con \u00e9l conseguimos enviar y recibir datos por un \u00fanico cable. Esto tiene sus ventajas e inconvenientes, pero no deja de ser una opci\u00f3n muy a tener en cuenta cuando vamos justos de conexiones de control para nuestro proyecto, ya que nos ahorramos un cable en cada sensor. En otro ejemplo, ya realizamos mediciones de temperatura con un sensor. Lo interesante de este ejemplo no es el medir la temperatura, si no aprender el funcionamiento del sistema OneWire, para poder usarlo en cualquier sensor que lo utilice, y la instalaci\u00f3n e importado de librer\u00edas de terceros. Existen muchos detractores de este sistema, que ponen de manifiesto que el usarlo exige unos c\u00f3digos algo complicados\u2026y que el conexionado no es demasiado intuitivo\u2026 La verdad es que ni son tan complicados los c\u00f3digos, ya que las librer\u00edas propias y los ejemplos que traen estos sensores son una buena herramienta, ni es tan complicada su conexi\u00f3n, solo hay que seguir el esquema que os daremos posteriormente. Como ver\u00e9is en Internet, la mayor\u00eda de errores y problemas de las personas que los usan radican en un mal conexionado.","title":"\u00bfQu\u00e9 es el sistema OneWire?"},{"location":"09_medicion_temperatura_ds18b20/#como-usar-las-librerias-y-los-ejemplos","text":"Esta vez, usaremos unas librer\u00edas en nuestro proyecto para controlar el sensor t\u00e9rmico con el sistema OneWire que os hemos comentado. En nuestro post 3, os definimos qu\u00e9 eran las librer\u00edas y ahora os explicaremos como usarlas. Arduino tiene una serie de librer\u00edas gen\u00e9ricas que podemos usar simplemente escribiendo al principio de nuestro c\u00f3digo la sentencia #include < librer\u00eda .h> repitiendo con todas las librer\u00edas que necesitemos. Ilustraci\u00f3n 1 Importaci\u00f3n de librer\u00edas en IDE Arduino En este ejemplo vamos a usar las librer\u00edas propias del sensor en cuesti\u00f3n, en nuestro caso usaremos las librer\u00edas DallasTemperature y OneWire . Para instalar las librer\u00edas propias, o de terceros, una vez descargadas existen 2 m\u00e9todos: 1. M\u00e9todo normal : Dentro del IDE, nos dirigimos a Sketch->Importar librer\u00eda->Ad library \u2026. Se nos abrir\u00e1 una ventana de exploraci\u00f3n en la que debemos buscar el archivo rar/zip que hemos descargado. Lo seleccionamos y ya la tendremos instalada. Ilustraci\u00f3n 2 Instalaci\u00f3n de librer\u00edas en IDE Arduino 2. M\u00e9todo manual : Si el m\u00e9todo anterior no funciona, utilizaremos la instalaci\u00f3n manual. Para proceder, descomprimiremos el rar/zip descargado y copiamos la carpeta de la librer\u00eda en la ruta Documentos\\Arduino\\libraries . Quedando, por ejemplo, de la siguiente manera. Ilustraci\u00f3n 3 Ejemplo de carpeta de librer\u00eda instalada Una vez instaladas las librer\u00edas que vayamos a usar, podremos usar los ejemplos que traen cada una para probar sus accesorios. Es interesante echarles un ojo antes de ponernos a programar como locos, porque de estos ejemplos podemos aprovechar partes de c\u00f3digo o ver c\u00f3mo usa las funciones\u2026 y as\u00ed ahorrarnos mucho trabajo. Para abrir estos ejemplos solo tendremos que dirigirnos dentro del IDE a Archivo->Ejemplos y ah\u00ed veremos todas las librer\u00edas disponibles y dentro de cada una, sus ejemplos correspondientes. Ilustraci\u00f3n 4 Cargar ejemplos","title":"\u00bfC\u00f3mo usar las librer\u00edas y los ejemplos?"},{"location":"09_medicion_temperatura_ds18b20/#ejemplo-medicion-de-temperatura-con-sensor-ds18b20","text":"Para empezar con este ejemplo detallaremos el material necesario. \u2022 1 x Arduino UNO R3 \u2022 1 x Protoboard \u2022 1 x Sensor de Temperatura ds18b20 (versi\u00f3n sumergible) \u2022 1 x Resistencia de 4,7k\u2126 \u2022 Cables para conectar todo En esta ocasi\u00f3n, es muy importante que prest\u00e9is atenci\u00f3n al montaje del circuito. No es para nada dif\u00edcil, pero si no est\u00e1 correcto el sensor dar\u00e1 medidas err\u00f3neas o incluso puede estropearse. El esquema es el siguiente: Ilustraci\u00f3n 5 Montaje para el sensor ds18b20 Como observamos en el circuito, alimentaremos a trav\u00e9s del pin DATA, por medio de la resistencia de 4,7k\u2126, y los pines VCC y GND van conectados entre s\u00ed y a tierra. Aqu\u00ed en el datasheet del sensor pod\u00e9is ver c\u00f3mo va el patillaje, o bien si us\u00e1is la versi\u00f3n sumergible, como nosotros, la correspondencia de los 3 cables ser\u00eda: [Rojo]=VCC, [Azul o Negro] = GND y [Amarillo o Blanco] = DATA. Una vez conectado todo correctamente, nos dirigiremos al IDE y escribiremos el siguiente c\u00f3digo. /******************************/ /* Medir Temperatura ds18b20 */ /******************************/ /*** Librer\u00edas ***/ #include <OneWire.h> //Se importan las librer\u00edas #include <DallasTemperature.h> //** Definiciones **// #define Pin 2 //Se declara el pin donde se conectar\u00e1 la DATA OneWire ourWire(Pin); //Se establece el pin declarado como bus para la comunicaci\u00f3n OneWire DallasTemperature sensors(&ourWire); //Se llama a la librer\u00eda DallasTemperature //** Programa **// void setup() { delay(1000); Serial.begin(9600); sensors.begin(); //Se inician los sensores } void loop() { sensors.requestTemperatures(); //Prepara el sensor para la lectura Serial.print(sensors.getTempCByIndex(0)); //Se lee e imprime la temperatura en grados Centigrados Serial.println(\" Grados Centigrados\"); delay(1000); //Se provoca una parada de 1 segundo antes de la pr\u00f3xima lectura } (Panama hiteck) En el programa, simplemente comenzaremos importando las librer\u00edas, OneWire y DallasTemperature, de la forma que coment\u00e1bamos m\u00e1s arriba. Continuaremos definiendo el pin que utilizaremos como bus de datos. Para ello usaremos la sentencia #define , la cual nos permite crear un valor constante pero con la ventaja de no consumir la RAM que usar\u00eda, al compilar, la creaci\u00f3n de una variable. Hay que tener la precauci\u00f3n de escribir correctamente las definiciones por que pueden provocar el lastrado de errores a lo largo de todo el c\u00f3digo si no se hace bien. En nuestro caso asignaremos el pin 2 para el bus. Con la l\u00ednea OneWire ourWire(Pin) , le decimos al sensor a trav\u00e9s de que pin se debe comunicar con Arduino y con DallasTemperature sensors(&ourWire) llamaremos a la librer\u00eda de Dallas para que interprete los datos enviados y recibidos por nuestro bus. Seguidamente, en nuestra funci\u00f3n de setup, iniciaremos la comunicaci\u00f3n serial a 9600 bits/seg y con la sentencia sensors.begin() activaremos los sensores que estemos usando. Nuestro c\u00f3digo en bucle, lo que har\u00e1 ser\u00e1 primero preparar al sensor ds18b20 para medir, usando la funci\u00f3n sensors.requestTemperatures() y con la l\u00ednea Serial.print(sensors.getTempCByIndex(0)) tomar\u00e1 la medida y la imprimir\u00e1, por el monitor serial y en grados cent\u00edgrados, en una \u00fanica sentencia. Finalmente a\u00f1adiremos la impresi\u00f3n del texto \u201c Grados Cent\u00edgrados \u201d y haremos una pausa de 1 segundo para que el sensor no est\u00e9 realizando miles de medidas constantemente. Ilustraci\u00f3n 6 Visualizaci\u00f3n de la temperatura en el monitor serial Como hab\u00e9is podido comprobar, es muy sencillo y pr\u00e1ctico utilizar este sistema. Solo hay que familiarizarse con las funciones espec\u00edficas de la librer\u00eda de cada sensor para sacarles el m\u00e1ximo provecho. Os recomendamos que le\u00e1is que funciones espec\u00edficas trae cada librer\u00eda y jugu\u00e9is un poco con ellas antes de poneros a programar vuestro proyecto, seguro que encontrar\u00e9is algunas funciones o ejemplos propios que os simplifican el c\u00f3digo bastante. Ilustraci\u00f3n 7 Montaje para el sensor ds18b20","title":"Ejemplo: Medici\u00f3n de temperatura con sensor ds18b20"},{"location":"10_pantalla_lcd/","text":"Descripci\u00f3n del proyecto En este \u00faltimo post del primer tutorial veremos c\u00f3mo mostrar a trav\u00e9s de una pantalla LCD la temperatura medida con el sensor LM35 que ya aprendimos a utilizar en el post 5. \u00bfuna pantalla LCD? S\u00ed, pero no la confundamos con la pantalla de nuestra televisi\u00f3n o la de nuestro smartphone, esas son pantallas LCD-TFT,LCD-SPI... nosotros usaremos una LCD simple y a un s\u00f3lo color del tipo de las que podemos encontrar en calculadoras y algunos electrodom\u00e9sticos. Material necesario Suponiendo que ya tenemos nuestra placa Arduino Uno, nuestra protoboard y un juego de cables, tendremos que hacernos con el siguiente material: Pantalla LCD . En este caso he elegido una de 16 columnas y 2 l\u00edneas (16x2) por ser probablemente la m\u00e1s com\u00fan. En tiendas online las he visto por unos 4 \u20ac env\u00edo incluido. Sensor LM35 . Si seguiste el post 5 probablemente ya lo tendr\u00e1s. Si no tampoco te preocupes porque no valdr\u00e1 m\u00e1s de 2\u20ac . Potenci\u00f3metro 10k. Lo necesitamos para ajustar el contraste de a pantalla. Sin \u00e9l ser\u00eda ilegible. Cuesta pocos c\u00e9ntimos. Montaje Viendo la foto puede parecer complicado por la cantidad de cables que tiene, pero en realidad tener m\u00e1s conexiones no lo hace m\u00e1s dif\u00edcil. Si hacemos las conexiones paso a paso nos funcionar\u00e1 a la primera. La que vamos a ver no es la \u00fanica forma de conectar la pantalla, pero as\u00ed podemos utilizar los c\u00f3digos de ejemplo de la IDE para LCD sin cambiar ninguna l\u00ednea. Tambi\u00e9n ten\u00e9is que tener en cuenta que las pantallas las suelen vender con el agujero para soldarle un pin macho o un cable. Yo le he soldado una tira de pines macho para poder insertarla en la protoboard pero si no quer\u00e9is soldar pod\u00e9is meter los cables en los agujero con cuidado de que las puntas no se toquen entre s\u00ed. Ahora vamos a ver de izquierda a derecha como se conecta cada pin de la pantalla. Como los pines 5V y GND los vamos a utilizar en m\u00e1s de una conexi\u00f3n, los conectamos a las filas largas de nuestra protoboard y cuando un pin de la pantalla se corresponda con 5V o GND lo conectaremos con su fila correspondiente. VSS a la fila GND VDD a la fila 5 V V0 a la pata central del potenci\u00f3metro RS al pin 12 RW a la fila GND E al pin 11 D0 a D3 sin conexi\u00f3n D4 al pin 5 D5 al pin 4 D6 al pin 3 D7 al pin 2 A a la fila 5 V K a la fila GND Del potenci\u00f3metro conectamos una de las patas libres a GND y otra a 5 V Pata VS del sensor a la fila 5 V Pata central del sensor al pin A0 Pata GND del sensor a la fila GND Si la pantalla no tiene iluminaci\u00f3n prescindiremos de los pines A y K No debemos olvidar que la primera vez que se conecta, tras alimentarla debemos ajustar el potenci\u00f3metro hasta encontrar el contraste \u00f3ptimo. Antes de seguir podemos verificar que funciona perfectamente cargando uno de los c\u00f3digos de ejemplo de la IDE como el que encontramos en Archivo \u2192 Ejemplos \u2192 LiquidCrystal \u2192 HelloWorld. C\u00f3digo S\u00f3lo vamos a tratar en profundidad la parte del c\u00f3digo que tiene que ver con el LCD y no con el sensor ya que est\u00e1 visto anteriormente. Al final del post est\u00e1 el c\u00f3digo completo. En primer lugar teneos que a\u00f1adir la librer\u00eda para LCD en Esketch \u2192 Importar librer\u00eda \u2192 LiquidCrystal o escribiendo #include <LiquidCrystal.h> Como la configuraci\u00f3n de algunos pines puede variar tenemos que indicarle a la librer\u00eda cu\u00e1les hemos utilizado. LiquidCrysta lcd(12,11,5,4,3,2); Ya podemos pasar a la funci\u00f3n setup . Ahora iniciamos el LCD. lcd.begin(6,2); El 16 y el 2 se refiere al n\u00famero de columnas y filas de nuestra pantalla. Lo siguiente es pasar a la funci\u00f3n loop e indicar en qu\u00e9 posici\u00f3n de la pantalla queremos el cursor. De manera gen\u00e9rica, el comando es: lcd.setCursor(columna, fila); Pero ojo, empieza a contar desde cero, es decir, si queremos el cursor en la primera columna de la primera fila tendremos que escribir: let.setCursor(0,0) Una vez situado el cursor escribimos por pantalla la cadena de caracteres \u201cTemperatura:\u201d. Las cadenas de caracteres van entre comillas. lcd.print(\u201cTemperatura:\u201d); Suponiendo que ya hemos le\u00eddo la temperatura y la tenemos almacenada en una variable llamada temp falta mostrarla por pantalla. Para que quepa la escribimos en la primera columna de la segunda fila: lcd.setCursor(0, 1); lcd.print(temp); Y con esto escribir\u00e1 el n\u00famero que amacena la variable temp . Para que nuestro proyecto quede m\u00e1s est\u00e9tico escribiremos la cadena de caracteres \u201cC\u201d en la octava columna de la segunda fila (el s\u00edmbolo \u201c\u00ba\u201d no se muestra correctamente). lcd.setCursor(7, 1); lcd.print(\u201cC\u201d); Aunque es este c\u00f3digo no vamos a tener problemas al sobrescribir, tenemos que tener en cuenta que s\u00f3lo se borran las posiciones en las que se escriben, el resto sigue manteniendo los caracteres que mostraban anteriormente. Para limpiar la pantalla utilizaremos la opci\u00f3n clear que borrar\u00e1 toda la pantalla. lcd.clear(); Por \u00faltimo, introducimos un delay al gusto para evitar que refresque tan r\u00e1pido que no nos de tiempo a leer los datos antes de que cambien.","title":"10 pantalla lcd"},{"location":"10_pantalla_lcd/#descripcion-del-proyecto","text":"En este \u00faltimo post del primer tutorial veremos c\u00f3mo mostrar a trav\u00e9s de una pantalla LCD la temperatura medida con el sensor LM35 que ya aprendimos a utilizar en el post 5. \u00bfuna pantalla LCD? S\u00ed, pero no la confundamos con la pantalla de nuestra televisi\u00f3n o la de nuestro smartphone, esas son pantallas LCD-TFT,LCD-SPI... nosotros usaremos una LCD simple y a un s\u00f3lo color del tipo de las que podemos encontrar en calculadoras y algunos electrodom\u00e9sticos.","title":"Descripci\u00f3n del proyecto"},{"location":"10_pantalla_lcd/#material-necesario","text":"Suponiendo que ya tenemos nuestra placa Arduino Uno, nuestra protoboard y un juego de cables, tendremos que hacernos con el siguiente material: Pantalla LCD . En este caso he elegido una de 16 columnas y 2 l\u00edneas (16x2) por ser probablemente la m\u00e1s com\u00fan. En tiendas online las he visto por unos 4 \u20ac env\u00edo incluido. Sensor LM35 . Si seguiste el post 5 probablemente ya lo tendr\u00e1s. Si no tampoco te preocupes porque no valdr\u00e1 m\u00e1s de 2\u20ac . Potenci\u00f3metro 10k. Lo necesitamos para ajustar el contraste de a pantalla. Sin \u00e9l ser\u00eda ilegible. Cuesta pocos c\u00e9ntimos.","title":"Material necesario"},{"location":"10_pantalla_lcd/#montaje","text":"Viendo la foto puede parecer complicado por la cantidad de cables que tiene, pero en realidad tener m\u00e1s conexiones no lo hace m\u00e1s dif\u00edcil. Si hacemos las conexiones paso a paso nos funcionar\u00e1 a la primera. La que vamos a ver no es la \u00fanica forma de conectar la pantalla, pero as\u00ed podemos utilizar los c\u00f3digos de ejemplo de la IDE para LCD sin cambiar ninguna l\u00ednea. Tambi\u00e9n ten\u00e9is que tener en cuenta que las pantallas las suelen vender con el agujero para soldarle un pin macho o un cable. Yo le he soldado una tira de pines macho para poder insertarla en la protoboard pero si no quer\u00e9is soldar pod\u00e9is meter los cables en los agujero con cuidado de que las puntas no se toquen entre s\u00ed. Ahora vamos a ver de izquierda a derecha como se conecta cada pin de la pantalla. Como los pines 5V y GND los vamos a utilizar en m\u00e1s de una conexi\u00f3n, los conectamos a las filas largas de nuestra protoboard y cuando un pin de la pantalla se corresponda con 5V o GND lo conectaremos con su fila correspondiente. VSS a la fila GND VDD a la fila 5 V V0 a la pata central del potenci\u00f3metro RS al pin 12 RW a la fila GND E al pin 11 D0 a D3 sin conexi\u00f3n D4 al pin 5 D5 al pin 4 D6 al pin 3 D7 al pin 2 A a la fila 5 V K a la fila GND Del potenci\u00f3metro conectamos una de las patas libres a GND y otra a 5 V Pata VS del sensor a la fila 5 V Pata central del sensor al pin A0 Pata GND del sensor a la fila GND Si la pantalla no tiene iluminaci\u00f3n prescindiremos de los pines A y K No debemos olvidar que la primera vez que se conecta, tras alimentarla debemos ajustar el potenci\u00f3metro hasta encontrar el contraste \u00f3ptimo. Antes de seguir podemos verificar que funciona perfectamente cargando uno de los c\u00f3digos de ejemplo de la IDE como el que encontramos en Archivo \u2192 Ejemplos \u2192 LiquidCrystal \u2192 HelloWorld. C\u00f3digo S\u00f3lo vamos a tratar en profundidad la parte del c\u00f3digo que tiene que ver con el LCD y no con el sensor ya que est\u00e1 visto anteriormente. Al final del post est\u00e1 el c\u00f3digo completo. En primer lugar teneos que a\u00f1adir la librer\u00eda para LCD en Esketch \u2192 Importar librer\u00eda \u2192 LiquidCrystal o escribiendo #include <LiquidCrystal.h> Como la configuraci\u00f3n de algunos pines puede variar tenemos que indicarle a la librer\u00eda cu\u00e1les hemos utilizado. LiquidCrysta lcd(12,11,5,4,3,2); Ya podemos pasar a la funci\u00f3n setup . Ahora iniciamos el LCD. lcd.begin(6,2); El 16 y el 2 se refiere al n\u00famero de columnas y filas de nuestra pantalla. Lo siguiente es pasar a la funci\u00f3n loop e indicar en qu\u00e9 posici\u00f3n de la pantalla queremos el cursor. De manera gen\u00e9rica, el comando es: lcd.setCursor(columna, fila); Pero ojo, empieza a contar desde cero, es decir, si queremos el cursor en la primera columna de la primera fila tendremos que escribir: let.setCursor(0,0) Una vez situado el cursor escribimos por pantalla la cadena de caracteres \u201cTemperatura:\u201d. Las cadenas de caracteres van entre comillas. lcd.print(\u201cTemperatura:\u201d); Suponiendo que ya hemos le\u00eddo la temperatura y la tenemos almacenada en una variable llamada temp falta mostrarla por pantalla. Para que quepa la escribimos en la primera columna de la segunda fila: lcd.setCursor(0, 1); lcd.print(temp); Y con esto escribir\u00e1 el n\u00famero que amacena la variable temp . Para que nuestro proyecto quede m\u00e1s est\u00e9tico escribiremos la cadena de caracteres \u201cC\u201d en la octava columna de la segunda fila (el s\u00edmbolo \u201c\u00ba\u201d no se muestra correctamente). lcd.setCursor(7, 1); lcd.print(\u201cC\u201d); Aunque es este c\u00f3digo no vamos a tener problemas al sobrescribir, tenemos que tener en cuenta que s\u00f3lo se borran las posiciones en las que se escriben, el resto sigue manteniendo los caracteres que mostraban anteriormente. Para limpiar la pantalla utilizaremos la opci\u00f3n clear que borrar\u00e1 toda la pantalla. lcd.clear(); Por \u00faltimo, introducimos un delay al gusto para evitar que refresque tan r\u00e1pido que no nos de tiempo a leer los datos antes de que cambien.","title":"Montaje"}]}